/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => main_default
});
module.exports = __toCommonJS(main_exports);

// src/taskmarker-Plugin.ts
var import_obsidian4 = require("obsidian");

// src/taskmarker-TaskMarker.ts
var import_obsidian = require("obsidian");
var TaskMarker = class {
  constructor(app) {
    this.app = app;
    this.app = app;
    this.anyListItem = new RegExp(/^([\s>]*[-+*] )([^\\[].*)$/);
    this.anyTaskMark = new RegExp(/^([\s>]*[-+*] \[)(.)(\] .*)$/);
    this.blockQuote = new RegExp(/^(\s*>[\s>]*)(.*)$/);
    this.blockRef = new RegExp(/^(.*?)( \^[A-Za-z0-9-]+)?$/);
    this.continuation = new RegExp(/^( {2,}|\t)/);
    this.stripTask = new RegExp(/^([\s>]*[-+*]) \[.\] (.*)$/);
  }
  updateSettings(settings) {
    this.settings = settings;
    let momentMatchString = null;
    if (settings.appendDateFormat) {
      const literals = [];
      const regex1 = RegExp("(\\[.*?\\]\\]?)", "g");
      let match;
      let i = 0;
      momentMatchString = settings.appendDateFormat;
      while ((match = regex1.exec(momentMatchString)) !== null) {
        momentMatchString = momentMatchString.replace(
          match[0],
          `%$${i}$%`
        );
        literals.push(
          match[0].substring(1, match[0].length - 1).replace(/\(/g, "\\(").replace(/\)/g, "\\)").replace(/\[/g, "\\[").replace(/\]/g, "\\]")
        );
        i++;
      }
      momentMatchString = momentMatchString.replace("YYYY", "\\d{4}").replace("YY", "\\d{2}").replace("DD", "\\d{2}").replace("D", "\\d{1,2}").replace("MMM", "[A-Za-z]{3}").replace("MM", "\\d{2}").replace("M", "\\d{1,2}").replace("HH", "\\d{2}").replace("H", "\\d{1,2}").replace("hh", "\\d{2}").replace("h", "\\d{1,2}").replace("mm", "\\d{2}").replace("m", "\\d{1,2}");
      if (literals.length > 0) {
        for (let i2 = 0; i2 < literals.length; i2++) {
          momentMatchString = momentMatchString.replace(
            `%$${i2}$%`,
            literals[i2]
          );
        }
      }
      momentMatchString = `\\s*${momentMatchString}\\s*`;
    }
    if (settings.appendTextFormatMark) {
      const literals = [];
      const regex1 = RegExp("(\\[.*?\\]\\]?)", "g");
      let match;
      let i = 0;
      momentMatchString = settings.appendTextFormatMark;
      while ((match = regex1.exec(momentMatchString)) !== null) {
        momentMatchString = momentMatchString.replace(
          match[0],
          `%$${i}$%`
        );
        literals.push(
          match[0].substring(1, match[0].length - 1).replace(/\(/g, "\\(").replace(/\)/g, "\\)").replace(/\[/g, "\\[").replace(/\]/g, "\\]")
        );
        i++;
      }
      momentMatchString = momentMatchString.replace("YYYY", "\\d{4}").replace("YY", "\\d{2}").replace("DD", "\\d{2}").replace("D", "\\d{1,2}").replace("MMM", "[A-Za-z]{3}").replace("MM", "\\d{2}").replace("M", "\\d{1,2}").replace("HH", "\\d{2}").replace("H", "\\d{1,2}").replace("hh", "\\d{2}").replace("h", "\\d{1,2}").replace("mm", "\\d{2}").replace("m", "\\d{1,2}");
      if (literals.length > 0) {
        for (let i2 = 0; i2 < literals.length; i2++) {
          momentMatchString = momentMatchString.replace(
            `%$${i2}$%`,
            literals[i2]
          );
        }
      }
      momentMatchString = `\\s*${momentMatchString}\\s*`;
    }
    if (settings.appendTextFormatMarkRow2) {
      const literals = [];
      const regex1 = RegExp("(\\[.*?\\]\\]?)", "g");
      let match;
      let i = 0;
      momentMatchString = settings.appendTextFormatMarkRow2;
      while ((match = regex1.exec(momentMatchString)) !== null) {
        momentMatchString = momentMatchString.replace(
          match[0],
          `%$${i}$%`
        );
        literals.push(
          match[0].substring(1, match[0].length - 1).replace(/\(/g, "\\(").replace(/\)/g, "\\)").replace(/\[/g, "\\[").replace(/\]/g, "\\]")
        );
        i++;
      }
      momentMatchString = momentMatchString.replace("YYYY", "\\d{4}").replace("YY", "\\d{2}").replace("DD", "\\d{2}").replace("D", "\\d{1,2}").replace("MMM", "[A-Za-z]{3}").replace("MM", "\\d{2}").replace("M", "\\d{1,2}").replace("HH", "\\d{2}").replace("H", "\\d{1,2}").replace("hh", "\\d{2}").replace("h", "\\d{1,2}").replace("mm", "\\d{2}").replace("m", "\\d{1,2}");
      if (literals.length > 0) {
        for (let i2 = 0; i2 < literals.length; i2++) {
          momentMatchString = momentMatchString.replace(
            `%$${i2}$%`,
            literals[i2]
          );
        }
      }
      momentMatchString = `\\s*${momentMatchString}\\s*`;
    }
    if (settings.appendTextFormatCreation) {
      const literals = [];
      const regex1 = RegExp("(\\[.*?\\]\\]?)", "g");
      let match;
      let i = 0;
      momentMatchString = settings.appendTextFormatCreation;
      while ((match = regex1.exec(momentMatchString)) !== null) {
        momentMatchString = momentMatchString.replace(
          match[0],
          `%$${i}$%`
        );
        literals.push(
          match[0].substring(1, match[0].length - 1).replace(/\(/g, "\\(").replace(/\)/g, "\\)").replace(/\[/g, "\\[").replace(/\]/g, "\\]")
        );
        i++;
      }
      momentMatchString = momentMatchString.replace("YYYY", "\\d{4}").replace("YY", "\\d{2}").replace("DD", "\\d{2}").replace("D", "\\d{1,2}").replace("MMM", "[A-Za-z]{3}").replace("MM", "\\d{2}").replace("M", "\\d{1,2}").replace("HH", "\\d{2}").replace("H", "\\d{1,2}").replace("hh", "\\d{2}").replace("h", "\\d{1,2}").replace("mm", "\\d{2}").replace("m", "\\d{1,2}");
      if (literals.length > 0) {
        for (let i2 = 0; i2 < literals.length; i2++) {
          momentMatchString = momentMatchString.replace(
            `%$${i2}$%`,
            literals[i2]
          );
        }
      }
      momentMatchString = `\\s*${momentMatchString}\\s*`;
    }
    if (settings.appendTextFormatAppend) {
      const literals = [];
      const regex1 = RegExp("(\\[.*?\\]\\]?)", "g");
      let match;
      let i = 0;
      momentMatchString = settings.appendTextFormatAppend;
      while ((match = regex1.exec(momentMatchString)) !== null) {
        momentMatchString = momentMatchString.replace(
          match[0],
          `%$${i}$%`
        );
        literals.push(
          match[0].substring(1, match[0].length - 1).replace(/\(/g, "\\(").replace(/\)/g, "\\)").replace(/\[/g, "\\[").replace(/\]/g, "\\]")
        );
        i++;
      }
      momentMatchString = momentMatchString.replace("YYYY", "\\d{4}").replace("YY", "\\d{2}").replace("DD", "\\d{2}").replace("D", "\\d{1,2}").replace("MMM", "[A-Za-z]{3}").replace("MM", "\\d{2}").replace("M", "\\d{1,2}").replace("HH", "\\d{2}").replace("H", "\\d{1,2}").replace("hh", "\\d{2}").replace("h", "\\d{1,2}").replace("mm", "\\d{2}").replace("m", "\\d{1,2}");
      if (literals.length > 0) {
        for (let i2 = 0; i2 < literals.length; i2++) {
          momentMatchString = momentMatchString.replace(
            `%$${i2}$%`,
            literals[i2]
          );
        }
      }
      momentMatchString = `\\s*${momentMatchString}\\s*`;
    }
    if (settings.appendTextFormatAppendText2) {
      const literals = [];
      const regex1 = RegExp("(\\[.*?\\]\\]?)", "g");
      let match;
      let i = 0;
      momentMatchString = settings.appendTextFormatAppendText2;
      while ((match = regex1.exec(momentMatchString)) !== null) {
        momentMatchString = momentMatchString.replace(
          match[0],
          `%$${i}$%`
        );
        literals.push(
          match[0].substring(1, match[0].length - 1).replace(/\(/g, "\\(").replace(/\)/g, "\\)").replace(/\[/g, "\\[").replace(/\]/g, "\\]")
        );
        i++;
      }
      momentMatchString = momentMatchString.replace("YYYY", "\\d{4}").replace("YY", "\\d{2}").replace("DD", "\\d{2}").replace("D", "\\d{1,2}").replace("MMM", "[A-Za-z]{3}").replace("MM", "\\d{2}").replace("M", "\\d{1,2}").replace("HH", "\\d{2}").replace("H", "\\d{1,2}").replace("hh", "\\d{2}").replace("h", "\\d{1,2}").replace("mm", "\\d{2}").replace("m", "\\d{1,2}");
      if (literals.length > 0) {
        for (let i2 = 0; i2 < literals.length; i2++) {
          momentMatchString = momentMatchString.replace(
            `%$${i2}$%`,
            literals[i2]
          );
        }
      }
      momentMatchString = `\\s*${momentMatchString}\\s*`;
    }
    if (settings.appendTextFormatAppendText3) {
      const literals = [];
      const regex1 = RegExp("(\\[.*?\\]\\]?)", "g");
      let match;
      let i = 0;
      momentMatchString = settings.appendTextFormatAppendText3;
      while ((match = regex1.exec(momentMatchString)) !== null) {
        momentMatchString = momentMatchString.replace(
          match[0],
          `%$${i}$%`
        );
        literals.push(
          match[0].substring(1, match[0].length - 1).replace(/\(/g, "\\(").replace(/\)/g, "\\)").replace(/\[/g, "\\[").replace(/\]/g, "\\]")
        );
        i++;
      }
      momentMatchString = momentMatchString.replace("YYYY", "\\d{4}").replace("YY", "\\d{2}").replace("DD", "\\d{2}").replace("D", "\\d{1,2}").replace("MMM", "[A-Za-z]{3}").replace("MM", "\\d{2}").replace("M", "\\d{1,2}").replace("HH", "\\d{2}").replace("H", "\\d{1,2}").replace("hh", "\\d{2}").replace("h", "\\d{1,2}").replace("mm", "\\d{2}").replace("m", "\\d{1,2}");
      if (literals.length > 0) {
        for (let i2 = 0; i2 < literals.length; i2++) {
          momentMatchString = momentMatchString.replace(
            `%$${i2}$%`,
            literals[i2]
          );
        }
      }
      momentMatchString = `\\s*${momentMatchString}\\s*`;
    }
    const completedTasks = (this.settings.onlyLowercaseX ? "x" : "xX") + (this.settings.supportCanceledTasks ? "-" : "");
    if (this.settings.incompleteTaskValues.indexOf(" ") < 0) {
      this.settings.incompleteTaskValues = " " + this.settings.incompleteTaskValues;
    }
    const rightClickTaskMenu = this.settings.rightClickComplete || this.settings.rightClickMark || this.settings.rightClickCycle || this.settings.rightClickCycleList1 || this.settings.rightClickCycleList2 || this.settings.rightClickCycleList3 || this.settings.rightClickCycleReversely || this.settings.rightClickCreate || this.settings.rightClickAppend || this.settings.rightClickAppendText2 || this.settings.rightClickAppendText3 || this.settings.rightClickAppendTextAuto || // this.settings.rightClickMove ||
    this.settings.rightClickResetTask || this.settings.rightClickResetAll || this.settings.rightClickToggleAll;
    this.initSettings = {
      removeRegExp: this.tryCreateRemoveRegex(
        this.settings.removeExpression
      ),
      resetRegExp: this.tryCreateResetRegex(momentMatchString),
      incompleteTaskRegExp: this.tryCreateIncompleteRegex(
        this.settings.incompleteTaskValues
      ),
      incompleteTaskRegExpRow2: this.tryCreateIncompleteRegex(
        this.settings.incompleteTaskValuesRow2
      ),
      rightClickTaskMenu,
      registerHandlers: rightClickTaskMenu || this.settings.previewOnClick,
      completedTasks,
      completedTaskRegExp: this.tryCreateCompleteRegex(completedTasks)
    };
    console.debug(
      "Task Marker: updated configuration %o, %o",
      this.settings,
      this.initSettings
    );
  }
  tryCreateRemoveRegex(param) {
    return param ? new RegExp(param, "g") : null;
  }
  tryCreateResetRegex(param) {
    return param ? new RegExp(param + "( \\^[A-Za-z0-9-]+)?$") : null;
  }
  tryCreateCompleteRegex(param) {
    return new RegExp(`^([\\s>]*- \\[)[${param}](\\] .*)$`);
  }
  tryCreateIncompleteRegex(param) {
    return new RegExp(`^([\\s>]*- \\[)[${param}](\\] .*)$`);
  }
  removeCheckboxFromLine(lineText) {
    return lineText.replace(this.stripTask, "$1 $2");
  }
  /** _Complete_ a task: append completion text, remove configured strings */
  completeTaskLine(lineText, mark = "x") {
    console.debug("Task Marker: complete task with %s: %s", mark, lineText);
    let marked = lineText.replace(this.anyTaskMark, `$1${mark}$3`);
    if (this.initSettings.removeRegExp) {
      marked = marked.replace(this.initSettings.removeRegExp, "");
    }
    if (this.settings.appendDateFormat) {
      const strictLineEnding = lineText.endsWith("  ");
      let blockid = "";
      const match = this.blockRef.exec(marked);
      if (match && match[2]) {
        marked = match[1];
        blockid = match[2];
      }
      if (!marked.endsWith(" ")) {
        marked += " ";
      }
      marked += (0, import_obsidian.moment)().format(this.settings.appendDateFormat) + blockid;
      if (strictLineEnding) {
        marked += "  ";
      }
    }
    return marked;
  }
  markAllTasksComplete(source, mark) {
    const lines = source.split("\n");
    const result = [];
    for (const line of lines) {
      if (this.initSettings.incompleteTaskRegExp.exec(line)) {
        result.push(this.completeTaskLine(line, mark));
      } else if (this.initSettings.incompleteTaskRegExpRow2.exec(line)) {
        result.push(this.completeTaskLine(line, mark));
      } else {
        result.push(line);
      }
    }
    return result.join("\n");
  }
  markTaskInSource(source, mark, lines = []) {
    const split = source.split("\n");
    const cursorOffset = [];
    for (const n of lines) {
      const result = this.markTaskLine(split[n], mark);
      split[n] = result.updatedLineText;
      cursorOffset.push(result.cursorOffset);
    }
    return { updatedLineText: split.join("\n"), cursorOffset };
  }
  markTaskInSourceCycle(source, mark, lines = []) {
    const split = source.split("\n");
    const cursorOffset = [];
    for (const n of lines) {
      const result = this.markTaskLineCycle(split[n], mark);
      split[n] = result.updatedLineText;
      cursorOffset.push(result.cursorOffset);
    }
    return { updatedLineText: split.join("\n"), cursorOffset };
  }
  markTaskInSourceCycleList1(source, mark, lines = []) {
    const split = source.split("\n");
    const cursorOffset = [];
    for (const n of lines) {
      const result = this.markTaskLineCycleList1(split[n], mark);
      split[n] = result.updatedLineText;
      cursorOffset.push(result.cursorOffset);
    }
    return { updatedLineText: split.join("\n"), cursorOffset };
  }
  markTaskInSourceCycleList2(source, mark, lines = []) {
    const split = source.split("\n");
    const cursorOffset = [];
    for (const n of lines) {
      const result = this.markTaskLineCycleList2(split[n], mark);
      split[n] = result.updatedLineText;
      cursorOffset.push(result.cursorOffset);
    }
    return { updatedLineText: split.join("\n"), cursorOffset };
  }
  markTaskInSourceCycleList3(source, mark, lines = []) {
    const split = source.split("\n");
    const cursorOffset = [];
    for (const n of lines) {
      const result = this.markTaskLineCycleList3(split[n], mark);
      split[n] = result.updatedLineText;
      cursorOffset.push(result.cursorOffset);
    }
    return { updatedLineText: split.join("\n"), cursorOffset };
  }
  markTaskInSourceCycleReversely(source, mark, lines = []) {
    const split = source.split("\n");
    const cursorOffset = [];
    for (const n of lines) {
      const result = this.markTaskLineCycleReversely(split[n], mark);
      split[n] = result.updatedLineText;
      cursorOffset.push(result.cursorOffset);
    }
    return { updatedLineText: split.join("\n"), cursorOffset };
  }
  markTaskInSourceCreate(source, mark, lines = []) {
    const split = source.split("\n");
    const cursorOffset = [];
    for (const n of lines) {
      const result = this.markTaskLineCreate(split[n], mark);
      split[n] = result.updatedLineText;
      cursorOffset.push(result.cursorOffset);
    }
    return { updatedLineText: split.join("\n"), cursorOffset };
  }
  appendTextInSource(source, mark, lines = []) {
    const split = source.split("\n");
    for (const n of lines) {
      split[n] = this.appendTextLine(split[n], mark);
    }
    return split.join("\n");
  }
  appendTextInSourceText2(source, mark, lines = []) {
    const split = source.split("\n");
    for (const n of lines) {
      split[n] = this.appendTextLineText2(split[n], mark);
    }
    return split.join("\n");
  }
  appendTextInSourceText3(source, mark, lines = []) {
    const split = source.split("\n");
    for (const n of lines) {
      split[n] = this.appendTextLineText3(split[n], mark);
    }
    return split.join("\n");
  }
  appendTextInSourceAuto(source, mark, lines = []) {
    const split = source.split("\n");
    for (const n of lines) {
      split[n] = this.appendTextLineAuto(split[n], mark);
    }
    return split.join("\n");
  }
  markTaskLine(lineText, mark) {
    const taskMatch = this.anyTaskMark.exec(lineText);
    const taskPrefix = `${lineText.trim().charAt(0)} [`;
    const markString = taskPrefix + mark + "] ";
    let cursorOffset = 0;
    if (mark === "Backspace") {
      lineText = this.removeCheckboxFromLine(lineText);
    } else if (taskMatch) {
      const completeMark = this.initSettings.completedTasks.indexOf(mark) >= 0;
      if (mark !== " ") {
        if (lineText.trim().startsWith(markString)) {
          new import_obsidian.Notice(`Task Marker: task already marked with the same status "${mark}"!`);
        } else {
          let marked2 = lineText.replace(this.anyTaskMark, `$1${mark}$3`);
          if (this.initSettings.removeRegExp) {
            marked2 = marked2.replace(this.initSettings.removeRegExp, "");
          }
          if (this.settings.appendDateFormat && completeMark) {
            const strictLineEnding = lineText.endsWith("  ");
            let blockid = "";
            const match = this.blockRef.exec(marked2);
            if (match && match[2]) {
              marked2 = match[1];
              blockid = match[2];
            }
            if (!marked2.endsWith(" ")) {
              marked2 += " ";
            }
            marked2 += (0, import_obsidian.moment)().format(this.settings.appendDateFormat) + blockid;
            if (strictLineEnding) {
              marked2 += "  ";
            }
          } else if (this.settings.appendTextFormatMark && this.settings.incompleteTaskValues.indexOf(mark) >= 0) {
            const strictLineEnding = lineText.endsWith("  ");
            let blockid = "";
            const match = this.blockRef.exec(marked2);
            if (match && match[2]) {
              marked2 = match[1];
              blockid = match[2];
            }
            if (!marked2.endsWith(" ")) {
              marked2 += " ";
            }
            marked2 += (0, import_obsidian.moment)().format(this.settings.appendTextFormatMark) + blockid;
            if (strictLineEnding) {
              marked2 += "  ";
            }
          } else if (this.settings.appendTextFormatMarkRow2 && this.settings.incompleteTaskValuesRow2.indexOf(mark) >= 0) {
            const strictLineEnding = lineText.endsWith("  ");
            let blockid = "";
            const match = this.blockRef.exec(marked2);
            if (match && match[2]) {
              marked2 = match[1];
              blockid = match[2];
            }
            if (!marked2.endsWith(" ")) {
              marked2 += " ";
            }
            marked2 += (0, import_obsidian.moment)().format(this.settings.appendTextFormatMarkRow2) + blockid;
            if (strictLineEnding) {
              marked2 += "  ";
            }
          }
          lineText = marked2;
        }
      } else if (mark === " ") {
        lineText = this.resetTaskLine(lineText, mark);
      } else {
        new import_obsidian.Notice(`Task Marker: unknown mark ${mark}!`);
        console.log(
          "Task Marker: unknown mark (%s), leaving unchanged: %s",
          mark,
          lineText
        );
      }
    } else if (mark !== "Backspace") {
      const listMatch = this.anyListItem.exec(lineText);
      const taskPrefix2 = `${lineText.trim().charAt(0)} [`;
      if (listMatch && listMatch[2] || lineText.trim().startsWith(taskPrefix2)) {
        console.debug("Task Marker: list item, convert to a task %s", lineText);
        cursorOffset = 4;
        if (listMatch && listMatch[2]) {
          var marked = `${listMatch[1]}[ ] ${listMatch[2]}`;
        } else if (lineText.trim().startsWith(taskPrefix2)) {
          let listIndex = lineText.indexOf(taskPrefix2);
          var marked = lineText.slice(0, listIndex + 1) + " [ ] " + lineText.slice(listIndex + 2);
        }
        let result = this.markTaskLine(marked, mark);
        lineText = result.updatedLineText;
      } else {
        new import_obsidian.Notice(`Task Marker: not a task or list item!`);
        console.debug("Task Marker: not a task or list item %s", lineText);
      }
    }
    return { updatedLineText: lineText, cursorOffset };
  }
  markTaskLineCycle(lineText, mark) {
    const taskMatch = this.anyTaskMark.exec(lineText);
    const taskPrefix = `${lineText.trim().charAt(0)} [`;
    const listMatch = this.anyListItem.exec(lineText);
    const markValue = this.settings.cycleTaskValues;
    const markValueLength = markValue.length;
    const cycleWithList = this.settings.supportCyclingWithListItem;
    let cursorOffset = 0;
    let markStringArray = new Array(markValueLength);
    for (let i = 0; i < markValueLength; i++) {
      markStringArray[i] = `${lineText.trim().charAt(0)} [${markValue[i]}] `;
    }
    let markIndex = 0;
    for (let i = 0; i < markValueLength; i++) {
      if (lineText.trim().startsWith(markStringArray[i])) {
        if (i + 2 <= markValueLength) {
          markIndex = i + 1;
        } else {
          if (cycleWithList) {
            markIndex = -1;
            cursorOffset = -4;
          } else {
            markIndex = 0;
          }
        }
      }
    }
    if (markIndex === 0) {
      if (taskMatch) {
        if (cycleWithList) {
          markIndex = -1;
          cursorOffset = -4;
        }
      }
    }
    if (taskMatch) {
      if (markIndex === -1) {
        let listIndex = lineText.indexOf(taskPrefix);
        var marked = lineText.slice(0, listIndex + 1) + " " + lineText.slice(listIndex + 6);
      } else {
        var marked = lineText.replace(this.anyTaskMark, `$1${markValue[markIndex]}$3`);
      }
      const strictLineEnding = lineText.endsWith("  ");
      let blockid = "";
      const match = this.blockRef.exec(marked);
      if (match && match[2]) {
        marked = match[1];
        blockid = match[2];
      }
      marked += blockid;
      if (strictLineEnding) {
        marked += "  ";
      }
      lineText = marked;
    } else {
      if (listMatch && listMatch[2] || lineText.trim().startsWith(taskPrefix)) {
        console.debug("Task Marker: list item, convert to a task %s", lineText);
        cursorOffset = 4;
        if (listMatch && listMatch[2]) {
          var marked = `${listMatch[1]}[${markValue[0]}] ${listMatch[2]}`;
        } else if (lineText.trim().startsWith(taskPrefix)) {
          let listIndex = lineText.indexOf(taskPrefix);
          var marked = lineText.slice(0, listIndex + 1) + ` [${markValue[0]}] ` + lineText.slice(listIndex + 2);
        }
        const strictLineEnding = lineText.endsWith("  ");
        let blockid = "";
        const match = this.blockRef.exec(marked);
        if (match && match[2]) {
          marked = match[1];
          blockid = match[2];
        }
        marked += blockid;
        if (strictLineEnding) {
          marked += "  ";
        }
        lineText = marked;
      } else {
        new import_obsidian.Notice(`Task Marker: not a task or list item!`);
        console.debug("Task Marker: not a task or list item %s", lineText);
      }
    }
    return { updatedLineText: lineText, cursorOffset };
  }
  markTaskLineCycleList1(lineText, mark) {
    const taskMatch = this.anyTaskMark.exec(lineText);
    const taskPrefix = `${lineText.trim().charAt(0)} [`;
    const listMatch = this.anyListItem.exec(lineText);
    const markValue = this.settings.cycleTaskValuesList1;
    const markValueLength = markValue.length;
    const cycleWithList = this.settings.supportCyclingWithListItem;
    let cursorOffset = 0;
    let markStringArray = new Array(markValueLength);
    for (let i = 0; i < markValueLength; i++) {
      markStringArray[i] = `${lineText.trim().charAt(0)} [${markValue[i]}] `;
    }
    let markIndex = 0;
    for (let i = 0; i < markValueLength; i++) {
      if (lineText.trim().startsWith(markStringArray[i])) {
        if (i + 2 <= markValueLength) {
          markIndex = i + 1;
        } else {
          if (cycleWithList) {
            markIndex = -1;
            cursorOffset = -4;
          } else {
            markIndex = 0;
          }
        }
      }
    }
    if (markIndex === 0) {
      if (taskMatch) {
        if (cycleWithList) {
          markIndex = -1;
          cursorOffset = -4;
        }
      }
    }
    if (taskMatch) {
      if (markIndex === -1) {
        let listIndex = lineText.indexOf(taskPrefix);
        var marked = lineText.slice(0, listIndex + 1) + " " + lineText.slice(listIndex + 6);
      } else {
        var marked = lineText.replace(this.anyTaskMark, `$1${markValue[markIndex]}$3`);
      }
      const strictLineEnding = lineText.endsWith("  ");
      let blockid = "";
      const match = this.blockRef.exec(marked);
      if (match && match[2]) {
        marked = match[1];
        blockid = match[2];
      }
      marked += blockid;
      if (strictLineEnding) {
        marked += "  ";
      }
      lineText = marked;
    } else {
      if (listMatch && listMatch[2] || lineText.trim().startsWith(taskPrefix)) {
        console.debug("Task Marker: list item, convert to a task %s", lineText);
        cursorOffset = 4;
        if (listMatch && listMatch[2]) {
          var marked = `${listMatch[1]}[${markValue[0]}] ${listMatch[2]}`;
        } else if (lineText.trim().startsWith(taskPrefix)) {
          let listIndex = lineText.indexOf(taskPrefix);
          var marked = lineText.slice(0, listIndex + 1) + ` [${markValue[0]}] ` + lineText.slice(listIndex + 2);
        }
        const strictLineEnding = lineText.endsWith("  ");
        let blockid = "";
        const match = this.blockRef.exec(marked);
        if (match && match[2]) {
          marked = match[1];
          blockid = match[2];
        }
        marked += blockid;
        if (strictLineEnding) {
          marked += "  ";
        }
        lineText = marked;
      } else {
        new import_obsidian.Notice(`Task Marker: not a task or list item!`);
        console.debug("Task Marker: not a task or list item %s", lineText);
      }
    }
    return { updatedLineText: lineText, cursorOffset };
  }
  markTaskLineCycleList2(lineText, mark) {
    const taskMatch = this.anyTaskMark.exec(lineText);
    const taskPrefix = `${lineText.trim().charAt(0)} [`;
    const listMatch = this.anyListItem.exec(lineText);
    const markValue = this.settings.cycleTaskValuesList2;
    const markValueLength = markValue.length;
    const cycleWithList = this.settings.supportCyclingWithListItem;
    let cursorOffset = 0;
    let markStringArray = new Array(markValueLength);
    for (let i = 0; i < markValueLength; i++) {
      markStringArray[i] = `${lineText.trim().charAt(0)} [${markValue[i]}] `;
    }
    let markIndex = 0;
    for (let i = 0; i < markValueLength; i++) {
      if (lineText.trim().startsWith(markStringArray[i])) {
        if (i + 2 <= markValueLength) {
          markIndex = i + 1;
        } else {
          if (cycleWithList) {
            markIndex = -1;
            cursorOffset = -4;
          } else {
            markIndex = 0;
          }
        }
      }
    }
    if (markIndex === 0) {
      if (taskMatch) {
        if (cycleWithList) {
          markIndex = -1;
          cursorOffset = -4;
        }
      }
    }
    if (taskMatch) {
      if (markIndex === -1) {
        let listIndex = lineText.indexOf(taskPrefix);
        var marked = lineText.slice(0, listIndex + 1) + " " + lineText.slice(listIndex + 6);
      } else {
        var marked = lineText.replace(this.anyTaskMark, `$1${markValue[markIndex]}$3`);
      }
      const strictLineEnding = lineText.endsWith("  ");
      let blockid = "";
      const match = this.blockRef.exec(marked);
      if (match && match[2]) {
        marked = match[1];
        blockid = match[2];
      }
      marked += blockid;
      if (strictLineEnding) {
        marked += "  ";
      }
      lineText = marked;
    } else {
      if (listMatch && listMatch[2] || lineText.trim().startsWith(taskPrefix)) {
        console.debug("Task Marker: list item, convert to a task %s", lineText);
        cursorOffset = 4;
        if (listMatch && listMatch[2]) {
          var marked = `${listMatch[1]}[${markValue[0]}] ${listMatch[2]}`;
        } else if (lineText.trim().startsWith(taskPrefix)) {
          let listIndex = lineText.indexOf(taskPrefix);
          var marked = lineText.slice(0, listIndex + 1) + ` [${markValue[0]}] ` + lineText.slice(listIndex + 2);
        }
        const strictLineEnding = lineText.endsWith("  ");
        let blockid = "";
        const match = this.blockRef.exec(marked);
        if (match && match[2]) {
          marked = match[1];
          blockid = match[2];
        }
        marked += blockid;
        if (strictLineEnding) {
          marked += "  ";
        }
        lineText = marked;
      } else {
        new import_obsidian.Notice(`Task Marker: not a task or list item!`);
        console.debug("Task Marker: not a task or list item %s", lineText);
      }
    }
    return { updatedLineText: lineText, cursorOffset };
  }
  markTaskLineCycleList3(lineText, mark) {
    const taskMatch = this.anyTaskMark.exec(lineText);
    const taskPrefix = `${lineText.trim().charAt(0)} [`;
    const listMatch = this.anyListItem.exec(lineText);
    const markValue = this.settings.cycleTaskValuesList3;
    const markValueLength = markValue.length;
    const cycleWithList = this.settings.supportCyclingWithListItem;
    let cursorOffset = 0;
    let markStringArray = new Array(markValueLength);
    for (let i = 0; i < markValueLength; i++) {
      markStringArray[i] = `${lineText.trim().charAt(0)} [${markValue[i]}] `;
    }
    let markIndex = 0;
    for (let i = 0; i < markValueLength; i++) {
      if (lineText.trim().startsWith(markStringArray[i])) {
        if (i + 2 <= markValueLength) {
          markIndex = i + 1;
        } else {
          if (cycleWithList) {
            markIndex = -1;
            cursorOffset = -4;
          } else {
            markIndex = 0;
          }
        }
      }
    }
    if (markIndex === 0) {
      if (taskMatch) {
        if (cycleWithList) {
          markIndex = -1;
          cursorOffset = -4;
        }
      }
    }
    if (taskMatch) {
      if (markIndex === -1) {
        let listIndex = lineText.indexOf(taskPrefix);
        var marked = lineText.slice(0, listIndex + 1) + " " + lineText.slice(listIndex + 6);
      } else {
        var marked = lineText.replace(this.anyTaskMark, `$1${markValue[markIndex]}$3`);
      }
      const strictLineEnding = lineText.endsWith("  ");
      let blockid = "";
      const match = this.blockRef.exec(marked);
      if (match && match[2]) {
        marked = match[1];
        blockid = match[2];
      }
      marked += blockid;
      if (strictLineEnding) {
        marked += "  ";
      }
      lineText = marked;
    } else {
      if (listMatch && listMatch[2] || lineText.trim().startsWith(taskPrefix)) {
        console.debug("Task Marker: list item, convert to a task %s", lineText);
        cursorOffset = 4;
        if (listMatch && listMatch[2]) {
          var marked = `${listMatch[1]}[${markValue[0]}] ${listMatch[2]}`;
        } else if (lineText.trim().startsWith(taskPrefix)) {
          let listIndex = lineText.indexOf(taskPrefix);
          var marked = lineText.slice(0, listIndex + 1) + ` [${markValue[0]}] ` + lineText.slice(listIndex + 2);
        }
        const strictLineEnding = lineText.endsWith("  ");
        let blockid = "";
        const match = this.blockRef.exec(marked);
        if (match && match[2]) {
          marked = match[1];
          blockid = match[2];
        }
        marked += blockid;
        if (strictLineEnding) {
          marked += "  ";
        }
        lineText = marked;
      } else {
        new import_obsidian.Notice(`Task Marker: not a task or list item!`);
        console.debug("Task Marker: not a task or list item %s", lineText);
      }
    }
    return { updatedLineText: lineText, cursorOffset };
  }
  markTaskLineCycleReversely(lineText, mark) {
    const taskMatch = this.anyTaskMark.exec(lineText);
    const taskPrefix = `${lineText.trim().charAt(0)} [`;
    const listMatch = this.anyListItem.exec(lineText);
    var markValue = this.settings.cycleTaskValues;
    const markValueLength = markValue.length;
    const cycleWithList = this.settings.supportCyclingWithListItem;
    let cursorOffset = 0;
    let reverseString = "";
    for (let char of markValue) {
      reverseString = char + reverseString;
    }
    markValue = reverseString;
    let markStringArray = new Array(markValueLength);
    for (let i = 0; i < markValueLength; i++) {
      markStringArray[i] = `${lineText.trim().charAt(0)} [${markValue[i]}] `;
    }
    let markIndex = 0;
    for (let i = 0; i < markValueLength; i++) {
      if (lineText.trim().startsWith(markStringArray[i])) {
        if (i + 2 <= markValueLength) {
          markIndex = i + 1;
        } else {
          if (cycleWithList) {
            markIndex = -1;
            cursorOffset = -4;
          } else {
            markIndex = 0;
          }
        }
      }
    }
    if (markIndex === 0) {
      if (taskMatch) {
        if (cycleWithList) {
          markIndex = -1;
          cursorOffset = -4;
        }
      }
    }
    if (taskMatch) {
      if (markIndex === -1) {
        let listIndex = lineText.indexOf(taskPrefix);
        var marked = lineText.slice(0, listIndex + 1) + " " + lineText.slice(listIndex + 6);
      } else {
        var marked = lineText.replace(this.anyTaskMark, `$1${markValue[markIndex]}$3`);
      }
      const strictLineEnding = lineText.endsWith("  ");
      let blockid = "";
      const match = this.blockRef.exec(marked);
      if (match && match[2]) {
        marked = match[1];
        blockid = match[2];
      }
      marked += blockid;
      if (strictLineEnding) {
        marked += "  ";
      }
      lineText = marked;
    } else {
      if (listMatch && listMatch[2] || lineText.trim().startsWith(taskPrefix)) {
        console.debug("Task Marker: list item, convert to a task %s", lineText);
        cursorOffset = 4;
        if (listMatch && listMatch[2]) {
          var marked = `${listMatch[1]}[${markValue[markIndex]}] ${listMatch[2]}`;
        } else if (lineText.trim().startsWith(taskPrefix)) {
          let listIndex = lineText.indexOf(taskPrefix);
          var marked = lineText.slice(0, listIndex + 1) + ` [${markValue[markIndex]}] ` + lineText.slice(listIndex + 2);
        }
        const strictLineEnding = lineText.endsWith("  ");
        let blockid = "";
        const match = this.blockRef.exec(marked);
        if (match && match[2]) {
          marked = match[1];
          blockid = match[2];
        }
        marked += blockid;
        if (strictLineEnding) {
          marked += "  ";
        }
        lineText = marked;
      } else {
        new import_obsidian.Notice(`Task Marker: not a task or list item!`);
        console.debug("Task Marker: not a task or list item %s", lineText);
      }
    }
    return { updatedLineText: lineText, cursorOffset };
  }
  markTaskLineCreate(lineText, mark) {
    const taskMatch = this.anyTaskMark.exec(lineText);
    const taskPrefix = `${lineText.trim().charAt(0)} [ ] `;
    let cursorOffset = 0;
    if (taskMatch) {
      if (!lineText.trim().startsWith(taskPrefix)) {
        new import_obsidian.Notice(`Task Marker: task already marked!`);
        console.log("Task Marker: task already marked, leaving unchanged: %s", lineText);
      } else {
        let marked2 = lineText.replace(this.anyTaskMark, `$1${mark}$3`);
        if (this.settings.appendTextFormatCreation) {
          const strictLineEnding = lineText.endsWith("  ");
          let blockid = "";
          const match = this.blockRef.exec(marked2);
          if (match && match[2]) {
            marked2 = match[1];
            blockid = match[2];
          }
          if (!marked2.endsWith(" ")) {
            marked2 += " ";
          }
          marked2 += (0, import_obsidian.moment)().format(this.settings.appendTextFormatCreation) + blockid;
          if (strictLineEnding) {
            marked2 += "  ";
          }
        } else {
          console.log("Task Marker: appending string empty, nothing appended: %s", lineText);
        }
        lineText = marked2;
      }
    } else {
      const listMatch = this.anyListItem.exec(lineText);
      const taskPrefix2 = `${lineText.trim().charAt(0)} [`;
      if (listMatch && listMatch[2] || lineText.trim().startsWith(taskPrefix2)) {
        console.debug("Task Marker: list item, convert to a task %s", lineText);
        cursorOffset = 4;
        if (listMatch && listMatch[2]) {
          var marked = `${listMatch[1]}[ ] ${listMatch[2]}`;
        } else if (lineText.trim().startsWith(taskPrefix2)) {
          let listIndex = lineText.indexOf(taskPrefix2);
          var marked = lineText.slice(0, listIndex + 1) + " [ ] " + lineText.slice(listIndex + 2);
        }
        if (this.settings.appendTextFormatCreation) {
          const strictLineEnding = lineText.endsWith("  ");
          let blockid = "";
          const match = this.blockRef.exec(marked);
          if (match && match[2]) {
            marked = match[1];
            blockid = match[2];
          }
          if (!marked.endsWith(" ")) {
            marked += " ";
          }
          marked += (0, import_obsidian.moment)().format(this.settings.appendTextFormatCreation) + blockid;
          if (strictLineEnding) {
            marked += "  ";
          }
        } else {
          console.log("Task Marker: appending string empty, nothing appended: %s", lineText);
        }
        lineText = marked;
      } else {
        new import_obsidian.Notice(`Task Marker: not a task or list item!`);
        console.debug("Task Marker: not a task or list item %s", lineText);
      }
    }
    return { updatedLineText: lineText, cursorOffset };
  }
  appendTextLineFunction(lineText, appendTextFormat) {
    let marked = lineText;
    const strictLineEnding = lineText.endsWith("  ");
    let blockid = "";
    const match = this.blockRef.exec(marked);
    if (match && match[2]) {
      marked = match[1];
      blockid = match[2];
    }
    if (!marked.endsWith(" ")) {
      marked += " ";
    }
    marked += (0, import_obsidian.moment)().format(appendTextFormat) + blockid;
    if (strictLineEnding) {
      marked += "  ";
    }
    return marked;
  }
  appendTextLine(lineText, mark) {
    let marked = lineText;
    if (this.settings.appendTextFormatAppend) {
      marked = this.appendTextLineFunction(lineText, this.settings.appendTextFormatAppend);
    } else {
      new import_obsidian.Notice(`Task Marker: appending string empty!`);
      console.log("Task Marker: appending string empty, nothing appended: %s", lineText);
    }
    lineText = marked;
    return lineText;
  }
  appendTextLineText2(lineText, mark) {
    let marked = lineText;
    if (this.settings.appendTextFormatAppendText2) {
      marked = this.appendTextLineFunction(lineText, this.settings.appendTextFormatAppendText2);
    } else {
      new import_obsidian.Notice(`Task Marker: appending string empty!`);
      console.log("Task Marker: appending string empty, nothing appended: %s", lineText);
    }
    lineText = marked;
    return lineText;
  }
  appendTextLineText3(lineText, mark) {
    let marked = lineText;
    if (this.settings.appendTextFormatAppendText3) {
      marked = this.appendTextLineFunction(lineText, this.settings.appendTextFormatAppendText3);
    } else {
      new import_obsidian.Notice(`Task Marker: appending string empty!`);
      console.log("Task Marker: appending string empty, nothing appended: %s", lineText);
    }
    lineText = marked;
    return lineText;
  }
  appendTextLineAuto(lineText, mark) {
    let marked = lineText;
    const taskMatch = this.anyTaskMark.exec(lineText);
    if (taskMatch) {
      const taskMark = lineText.trim()[3];
      const createMark = taskMark === " ";
      const completeMark = this.initSettings.completedTasks.indexOf(taskMark) >= 0;
      const markRow1Mark = this.settings.incompleteTaskValues.indexOf(taskMark) >= 0;
      const markRow2Mark = this.settings.incompleteTaskValuesRow2.indexOf(taskMark) >= 0;
      const defaultTaskTextRows12 = this.settings.appendTextAutoTaskDefault === "text-rows-1-2";
      const defaultTaskTextRowString = this.settings.appendTextAutoTaskDefault === "text-row-string";
      const defaultTaskTextRow1 = this.settings.appendTextAutoTaskDefault === "text-row-1";
      const defaultTaskTextRow2 = this.settings.appendTextAutoTaskDefault === "text-row-2";
      const defaultTaskNone = this.settings.appendTextAutoTaskDefault === "none";
      if (createMark && this.settings.appendTextFormatCreation) {
        marked = this.appendTextLineFunction(lineText, this.settings.appendTextFormatCreation);
      } else if (completeMark && this.settings.appendDateFormat) {
        marked = this.appendTextLineFunction(lineText, this.settings.appendDateFormat);
      } else if (markRow1Mark || markRow2Mark) {
        if (defaultTaskTextRows12) {
          if (markRow1Mark && this.settings.appendTextFormatMark) {
            marked = this.appendTextLineFunction(lineText, this.settings.appendTextFormatMark);
          } else if (markRow2Mark && this.settings.appendTextFormatMarkRow2) {
            marked = this.appendTextLineFunction(lineText, this.settings.appendTextFormatMarkRow2);
          } else {
            new import_obsidian.Notice(`Task Marker: empty appending string!`);
            console.debug("Task Marker: empty appending string!");
          }
        } else if (defaultTaskTextRowString) {
          if (markRow1Mark && this.settings.appendTextFormatMark) {
            marked = this.appendTextLineFunction(lineText, this.settings.appendTextFormatMark);
          } else if (markRow1Mark && !this.settings.appendTextFormatMark && this.settings.appendTextFormatMarkRow2) {
            marked = this.appendTextLineFunction(lineText, this.settings.appendTextFormatMarkRow2);
          } else if (markRow2Mark && this.settings.appendTextFormatMarkRow2) {
            marked = this.appendTextLineFunction(lineText, this.settings.appendTextFormatMarkRow2);
          } else if (markRow2Mark && !this.settings.appendTextFormatMarkRow2 && this.settings.appendTextFormatMark) {
            marked = this.appendTextLineFunction(lineText, this.settings.appendTextFormatMark);
          } else {
            new import_obsidian.Notice(`Task Marker: empty appending string!`);
            console.debug("Task Marker: empty appending string!");
          }
        } else if (defaultTaskTextRow1) {
          if (markRow1Mark && this.settings.appendTextFormatMark) {
            marked = this.appendTextLineFunction(lineText, this.settings.appendTextFormatMark);
          } else if (markRow2Mark && this.settings.appendTextFormatMark) {
            marked = this.appendTextLineFunction(lineText, this.settings.appendTextFormatMark);
          } else {
            new import_obsidian.Notice(`Task Marker: empty appending string in row 1!`);
            console.debug("Task Marker: empty appending string in row 1!");
          }
        } else if (defaultTaskTextRow2) {
          if (markRow1Mark && this.settings.appendTextFormatMarkRow2) {
            marked = this.appendTextLineFunction(lineText, this.settings.appendTextFormatMarkRow2);
          } else if (markRow2Mark && this.settings.appendTextFormatMarkRow2) {
            marked = this.appendTextLineFunction(lineText, this.settings.appendTextFormatMarkRow2);
          } else {
            new import_obsidian.Notice(`Task Marker: empty appending string in row 2!`);
            console.debug("Task Marker: empty appending string in row 2!");
          }
        } else if (defaultTaskNone) {
          new import_obsidian.Notice(`Task Marker: set to append nothing!`);
          console.log("Task Marker: set to append nothing!");
        } else {
          new import_obsidian.Notice(`Task Marker: nothing to append!`);
          console.log("Task Marker: nothing to append!");
        }
      } else {
        new import_obsidian.Notice(`Task Marker: undefined mark or empty appending string!`);
        console.debug("Task Marker: undefined mark or empty appending string!");
      }
    } else {
      const defaultLineText1 = this.settings.appendTextAutoLineDefault === "text-1";
      const defaultLineText2 = this.settings.appendTextAutoLineDefault === "text-2";
      const defaultLineText3 = this.settings.appendTextAutoLineDefault === "text-3";
      const defaultLineNone = this.settings.appendTextAutoLineDefault === "none";
      if (defaultLineText1) {
        marked = this.appendTextLine(marked, "y");
      } else if (defaultLineText2) {
        marked = this.appendTextLineText2(marked, "y");
      } else if (defaultLineText3) {
        marked = this.appendTextLineText3(marked, "y");
      } else if (defaultLineNone) {
        new import_obsidian.Notice(`Task Marker: not a task, and set to append nothing!`);
        console.log("Task Marker: not a task, and set to append nothing!");
      } else {
        new import_obsidian.Notice(`Task Marker: not a task, and nothing to append!`);
        console.log("Task Marker: not a task, and nothing to append!");
      }
    }
    lineText = marked;
    return lineText;
  }
  resetTaskLine(lineText, mark = " ") {
    console.debug("Task Marker: reset task with %s: %s", mark, lineText);
    lineText = lineText.replace(this.anyTaskMark, `$1${mark}$3`);
    const strictLineEnding = lineText.endsWith("  ");
    let blockid = "";
    const match = this.blockRef.exec(lineText);
    if (match && match[2]) {
      lineText = match[1];
      blockid = match[2];
    }
    if (this.initSettings.resetRegExp) {
      lineText = lineText.replace(this.initSettings.resetRegExp, "");
    }
    lineText = lineText.replace(/\s*$/, blockid);
    if (this.settings.appendRemoveAllTasks && mark !== " ") {
      lineText = this.completeTaskLine(lineText, mark);
    }
    if (strictLineEnding) {
      lineText += "  ";
    }
    return lineText;
  }
  resetAllTasks(source) {
    const lines = source.split("\n");
    const result = [];
    let inCompletedSection = false;
    for (const line of lines) {
      if (inCompletedSection) {
        if (line.startsWith("#") || line.trim() === "---") {
          inCompletedSection = false;
        }
        result.push(line);
      } else if (this.isCompletedTaskLine(line)) {
        result.push(this.resetTaskLine(line));
      } else {
        result.push(line);
      }
    }
    return result.join("\n");
  }
  // moveCompletedTasksInFile(source: string): string {
  //     const LOG_HEADING = this.settings.completedAreaHeader || "## Log";
  //     const lines = source.split("\n");
  //     if (source.indexOf(LOG_HEADING) < 0) {
  //         if (lines[lines.length - 1].trim() !== "") {
  //             lines.push("");
  //         }
  //         lines.push(LOG_HEADING);
  //     }
  //     const remaining = [];
  //     const completedSection = [];
  //     const newTasks = [];
  //     let inCompletedSection = false;
  //     let inTask = false;
  //     let inCallout = false;
  //     let completedTasksIndex = lines.length;
  //     for (let line of lines) {
  //         if (inCompletedSection) {
  //             if (line.startsWith("#") || line.trim() === "---") {
  //                 inCompletedSection = false;
  //                 remaining.push(line);
  //             } else {
  //                 completedSection.push(line);
  //             }
  //         } else if (line.trim() === LOG_HEADING) {
  //             inCompletedSection = true;
  //             completedTasksIndex = remaining.push(line);
  //             remaining.push("%%%COMPLETED_ITEMS_GO_HERE%%%");
  //         } else {
  //             if (this.isCompletedTaskLine(line)) {
  //                 if (this.settings.completedAreaRemoveCheckbox) {
  //                     line = this.removeCheckboxFromLine(line);
  //                 }
  //                 inTask = true;
  //                 inCallout = this.isCallout(line); // is task _inside_ the callout
  //                 newTasks.push(line);
  //             } else if (
  //                 inTask &&
  //                 !this.isTaskLine(line) &&
  //                 this.isContinuation(line, inCallout)
  //             ) {
  //                 newTasks.push(line);
  //             } else {
  //                 inTask = false;
  //                 inCallout = false;
  //                 remaining.push(line);
  //             }
  //         }
  //     }
  //     let result = remaining
  //         .slice(0, completedTasksIndex)
  //         .concat(...newTasks)
  //         .concat(...completedSection);
  //     if (completedTasksIndex < remaining.length - 1) {
  //         result = result.concat(remaining.slice(completedTasksIndex + 1));
  //     }
  //     return result.join("\n");
  // }
  isCompletedTaskLine(lineText) {
    return this.initSettings.completedTaskRegExp.test(lineText);
  }
  isIncompleteTaskLine(lineText) {
    return this.initSettings.incompleteTaskRegExp.test(lineText) || this.initSettings.incompleteTaskRegExpRow2.test(lineText);
  }
  isTaskLine(lineText) {
    return this.anyTaskMark.test(lineText);
  }
  isContinuation(lineText, inCallout) {
    if (inCallout) {
      const match = this.blockQuote.exec(lineText);
      if (match) {
        return match[1].endsWith(">") || match[1].endsWith("  ") || match[1].endsWith("	");
      }
    }
    return this.continuation.test(lineText);
  }
  isCallout(lineText) {
    return this.blockQuote.test(lineText);
  }
};

// src/taskmarker-Settings.ts
var DEFAULT_SETTINGS = {
  // completedAreaHeader: "## Log",
  removeExpression: "",
  appendDateFormat: "",
  appendTextFormatMark: "",
  appendTextFormatMarkRow2: "",
  appendTextFormatCreation: "",
  appendTextFormatAppend: "",
  appendTextFormatAppendText2: "",
  appendTextFormatAppendText3: "",
  appendRemoveAllTasks: false,
  incompleteTaskValues: " ",
  incompleteTaskValuesRow2: "",
  // For choosing whether to show in the second row
  cycleTaskValues: "",
  cycleTaskValuesList1: "",
  cycleTaskValuesList2: "",
  cycleTaskValuesList3: "",
  onlyLowercaseX: false,
  supportCanceledTasks: true,
  supportCyclingTasksReversely: false,
  supportCyclingWithListItem: false,
  supportAppendingTextAutomatically: false,
  appendTextAutoLineDefault: "none",
  appendTextAutoTaskDefault: "none",
  previewOnClick: false,
  rightClickComplete: false,
  rightClickMark: false,
  rightClickCycle: false,
  rightClickCycleList1: false,
  rightClickCycleList2: false,
  rightClickCycleList3: false,
  rightClickCycleReversely: false,
  rightClickCreate: false,
  rightClickAppend: false,
  rightClickAppendText2: false,
  rightClickAppendText3: false,
  rightClickAppendTextAuto: false,
  // rightClickMove: false,
  rightClickResetTask: false,
  rightClickResetAll: false,
  rightClickToggleAll: false
  // completedAreaRemoveCheckbox: false,
};

// src/taskmarker-SettingsTab.ts
var import_obsidian2 = require("obsidian");
var TaskMarkerSettingsTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin, taskMarker) {
    super(app, plugin);
    this.plugin = plugin;
    this.taskMarker = taskMarker;
  }
  display() {
    this.containerEl.empty();
    this.containerEl.createEl("h1", { text: "Task Marker" });
    const tempSettings = Object.assign(
      this.taskMarker.settings
    );
    this.containerEl.createEl("h3", {
      text: "Please try reopening the vault or restarting Obsidian if the following setting changes do not take effect."
    });
    this.containerEl.createEl("h2", { text: "Create tasks" });
    new import_obsidian2.Setting(this.containerEl).setName("Append text to created task").setDesc(
      "Default empty. If set non-empty, append the string of moment.js format to the end of the task text."
    ).addMomentFormat(
      (momentFormat) => momentFormat.setPlaceholder("[\u{1F4DD} ]YYYY-MM-DD").setValue(tempSettings.appendTextFormatCreation).onChange((value) => __async(this, null, function* () {
        try {
          (0, import_obsidian2.moment)().format(value);
          tempSettings.appendTextFormatCreation = value;
          this.taskMarker.updateSettings(tempSettings);
          yield this.plugin.saveSettings();
        } catch (e) {
          console.log(
            `Error parsing specified date format: ${value}`
          );
        }
      }))
    );
    this.containerEl.appendChild(createEl("a", {
      text: "moment.js documentation.",
      href: "https://momentjs.com/docs",
      cls: "linkInfo"
    }));
    this.containerEl.createEl("h2", { text: "Complete tasks" });
    new import_obsidian2.Setting(this.containerEl).setName("Only support x for completed tasks").setDesc(
      "Only use 'x' (lower case) to indicate completed tasks (hide X (upper case))."
    ).addToggle(
      (toggle) => toggle.setValue(tempSettings.onlyLowercaseX).onChange((value) => __async(this, null, function* () {
        tempSettings.onlyLowercaseX = value;
        this.taskMarker.updateSettings(tempSettings);
        yield this.plugin.saveSettings();
      }))
    );
    new import_obsidian2.Setting(this.containerEl).setName("Support canceled tasks").setDesc(
      "Use '-' to indicate canceled tasks. Canceled tasks are processed in the same way as completed tasks."
    ).addToggle(
      (toggle) => toggle.setValue(tempSettings.supportCanceledTasks).onChange((value) => __async(this, null, function* () {
        tempSettings.supportCanceledTasks = value;
        this.taskMarker.updateSettings(tempSettings);
        yield this.plugin.saveSettings();
      }))
    );
    new import_obsidian2.Setting(this.containerEl).setName("Append text to completed task").setDesc(
      "Default empty. If set non-empty, append the string of moment.js format to the end of the task text."
    ).addMomentFormat(
      (momentFormat) => momentFormat.setPlaceholder("[\u2705 ]YYYY-MM-DD").setValue(tempSettings.appendDateFormat).onChange((value) => __async(this, null, function* () {
        try {
          (0, import_obsidian2.moment)().format(value);
          tempSettings.appendDateFormat = value;
          this.taskMarker.updateSettings(tempSettings);
          yield this.plugin.saveSettings();
        } catch (e) {
          console.log(
            `Error parsing specified date format: ${value}`
          );
        }
      }))
    );
    this.containerEl.createEl("h2", { text: "Mark tasks" });
    this.containerEl.createEl("p", {
      text: "Note that if a mark contains both in row 1 and row 2, then the mark would work as specified in row 1."
    });
    new import_obsidian2.Setting(this.containerEl).setName("Additional task statuses (row 1)").setDesc(
      "Specify the set of characters that indicate in-progress or incomplete tasks, e.g. 'i>!?D'. All of them (excluding the first open status) can be assigned with hotkeys."
    ).addText(
      (text) => text.setPlaceholder(">!?").setValue(tempSettings.incompleteTaskValues).onChange((value) => __async(this, null, function* () {
        if (value.contains("x")) {
          console.log(
            `Set of characters should not contain the marker for completed tasks (x): ${value}`
          );
        } else if (!tempSettings.onlyLowercaseX && value.contains("X")) {
          console.log(
            `Set of characters should not contain the marker for completed tasks (X): ${value}`
          );
        } else if (tempSettings.supportCanceledTasks && value.contains("-")) {
          console.log(
            `Set of characters should not contain the marker for canceled tasks (-): ${value}`
          );
        } else {
          if (!value.contains(" ")) {
            value = " " + value;
          }
          tempSettings.incompleteTaskValues = value;
          this.taskMarker.updateSettings(tempSettings);
          yield this.plugin.saveSettings();
        }
      }))
    );
    new import_obsidian2.Setting(this.containerEl).setName("Append text to marked task (row 1)").setDesc(
      "Default empty. If set non-empty, append the string of moment.js format to the end of the task text."
    ).addMomentFormat(
      (momentFormat) => momentFormat.setPlaceholder("[\u274E ]YYYY-MM-DD").setValue(tempSettings.appendTextFormatMark).onChange((value) => __async(this, null, function* () {
        try {
          (0, import_obsidian2.moment)().format(value);
          tempSettings.appendTextFormatMark = value;
          this.taskMarker.updateSettings(tempSettings);
          yield this.plugin.saveSettings();
        } catch (e) {
          console.log(
            `Error parsing specified date format: ${value}`
          );
        }
      }))
    );
    new import_obsidian2.Setting(this.containerEl).setName("Additional task statuses (row 2)").setDesc(
      "Specify the set of characters that indicate task statuses, e.g. 'Rip'. All of them can be assigned with hotkeys."
    ).addText(
      (text) => text.setPlaceholder("Rip").setValue(tempSettings.incompleteTaskValuesRow2).onChange((value) => __async(this, null, function* () {
        if (value.contains("x")) {
          console.log(
            `Set of characters should not contain the marker for completed tasks (x): ${value}`
          );
        } else if (!tempSettings.onlyLowercaseX && value.contains("X")) {
          console.log(
            `Set of characters should not contain the marker for completed tasks (X): ${value}`
          );
        } else if (tempSettings.supportCanceledTasks && value.contains("-")) {
          console.log(
            `Set of characters should not contain the marker for canceled tasks (-): ${value}`
          );
        } else {
          tempSettings.incompleteTaskValuesRow2 = value;
          this.taskMarker.updateSettings(tempSettings);
          yield this.plugin.saveSettings();
        }
      }))
    );
    new import_obsidian2.Setting(this.containerEl).setName("Append text to marked task (row 2)").setDesc(
      "Default empty. If set non-empty, append the string of moment.js format to the end of the task text."
    ).addMomentFormat(
      (momentFormat) => momentFormat.setPlaceholder("YYYY-MM-DD").setValue(tempSettings.appendTextFormatMarkRow2).onChange((value) => __async(this, null, function* () {
        try {
          (0, import_obsidian2.moment)().format(value);
          tempSettings.appendTextFormatMarkRow2 = value;
          this.taskMarker.updateSettings(tempSettings);
          yield this.plugin.saveSettings();
        } catch (e) {
          console.log(
            `Error parsing specified date format: ${value}`
          );
        }
      }))
    );
    this.containerEl.createEl("h2", { text: "Cycle tasks" });
    new import_obsidian2.Setting(this.containerEl).setName("Cycled task (main)").setDesc(
      "Specify a set of characters that indicate any task statuses, e.g. 'x- Rip>'."
    ).addText(
      (text) => text.setPlaceholder("x- Rip").setValue(tempSettings.cycleTaskValues).onChange((value) => __async(this, null, function* () {
        tempSettings.cycleTaskValues = value;
        this.taskMarker.updateSettings(tempSettings);
        yield this.plugin.saveSettings();
      }))
    );
    new import_obsidian2.Setting(this.containerEl).setName("Support cycling task reversely (main)").setDesc(
      "Default disabled. If enabled, a command would be added to cycle reversely among the statuses as specified above."
    ).addToggle(
      (toggle) => toggle.setValue(tempSettings.supportCyclingTasksReversely).onChange((value) => __async(this, null, function* () {
        tempSettings.supportCyclingTasksReversely = value;
        this.taskMarker.updateSettings(tempSettings);
        yield this.plugin.saveSettings();
      }))
    );
    new import_obsidian2.Setting(this.containerEl).setName("Cycled task (list 1)").setDesc(
      "Specify an additional list of characters that indicate any task statuses."
    ).addText(
      (text) => text.setPlaceholder("ab").setValue(tempSettings.cycleTaskValuesList1).onChange((value) => __async(this, null, function* () {
        tempSettings.cycleTaskValuesList1 = value;
        this.taskMarker.updateSettings(tempSettings);
        yield this.plugin.saveSettings();
      }))
    );
    new import_obsidian2.Setting(this.containerEl).setName("Cycled task (list 2)").setDesc(
      "Specify an additional list of characters that indicate any task statuses."
    ).addText(
      (text) => text.setPlaceholder("cd").setValue(tempSettings.cycleTaskValuesList2).onChange((value) => __async(this, null, function* () {
        tempSettings.cycleTaskValuesList2 = value;
        this.taskMarker.updateSettings(tempSettings);
        yield this.plugin.saveSettings();
      }))
    );
    new import_obsidian2.Setting(this.containerEl).setName("Cycled task (list 3)").setDesc(
      "Specify an additional list of characters that indicate any task statuses."
    ).addText(
      (text) => text.setPlaceholder("ef").setValue(tempSettings.cycleTaskValuesList3).onChange((value) => __async(this, null, function* () {
        tempSettings.cycleTaskValuesList3 = value;
        this.taskMarker.updateSettings(tempSettings);
        yield this.plugin.saveSettings();
      }))
    );
    new import_obsidian2.Setting(this.containerEl).setName("Support cycling with list item").setDesc(
      "Default disabled. If enabled, list item would be included as the first cycled status."
    ).addToggle(
      (toggle) => toggle.setValue(tempSettings.supportCyclingWithListItem).onChange((value) => __async(this, null, function* () {
        tempSettings.supportCyclingWithListItem = value;
        this.taskMarker.updateSettings(tempSettings);
        yield this.plugin.saveSettings();
      }))
    );
    this.containerEl.createEl("h2", { text: "Append text" });
    new import_obsidian2.Setting(this.containerEl).setName("Append text to any line (text 1)").setDesc(
      "Default empty. If set non-empty, append the string of moment.js format to the end of the line text."
    ).addMomentFormat(
      (momentFormat) => momentFormat.setPlaceholder("[\u{1F4DD} ]YYYY-MM-DD").setValue(tempSettings.appendTextFormatAppend).onChange((value) => __async(this, null, function* () {
        try {
          (0, import_obsidian2.moment)().format(value);
          tempSettings.appendTextFormatAppend = value;
          this.taskMarker.updateSettings(tempSettings);
          yield this.plugin.saveSettings();
        } catch (e) {
          console.log(
            `Error parsing specified date format: ${value}`
          );
        }
      }))
    );
    new import_obsidian2.Setting(this.containerEl).setName("Append text to any line (text 2)").setDesc(
      "Default empty. If set non-empty, append the string of moment.js format to the end of the line text."
    ).addMomentFormat(
      (momentFormat) => momentFormat.setPlaceholder("[\u2705 ]YYYY-MM-DD").setValue(tempSettings.appendTextFormatAppendText2).onChange((value) => __async(this, null, function* () {
        try {
          (0, import_obsidian2.moment)().format(value);
          tempSettings.appendTextFormatAppendText2 = value;
          this.taskMarker.updateSettings(tempSettings);
          yield this.plugin.saveSettings();
        } catch (e) {
          console.log(
            `Error parsing specified date format: ${value}`
          );
        }
      }))
    );
    new import_obsidian2.Setting(this.containerEl).setName("Append text to any line (text 3)").setDesc(
      "Default empty. If set non-empty, append the string of moment.js format to the end of the line text."
    ).addMomentFormat(
      (momentFormat) => momentFormat.setPlaceholder("[\u274E ]YYYY-MM-DD").setValue(tempSettings.appendTextFormatAppendText3).onChange((value) => __async(this, null, function* () {
        try {
          (0, import_obsidian2.moment)().format(value);
          tempSettings.appendTextFormatAppendText3 = value;
          this.taskMarker.updateSettings(tempSettings);
          yield this.plugin.saveSettings();
        } catch (e) {
          console.log(
            `Error parsing specified date format: ${value}`
          );
        }
      }))
    );
    this.containerEl.createEl("h2", { text: "Append text automatically" });
    this.containerEl.createEl("p", {
      text: 'The settings below correspond to the command "Append text automatically".'
    });
    this.containerEl.appendChild(createEl("a", {
      text: 'See "Setting.md" for details.',
      href: "https://github.com/wenlzhang/obsidian-task-marker/blob/main/docs/Setting.md",
      cls: "linkInfo"
    }));
    new import_obsidian2.Setting(this.containerEl).setName("Append text to a task automatically").setDesc(
      "Default false. If set true, automatically append text to tasks according to the current task status."
    ).addToggle(
      (toggle) => toggle.setValue(tempSettings.supportAppendingTextAutomatically).onChange((value) => __async(this, null, function* () {
        tempSettings.supportAppendingTextAutomatically = value;
        this.taskMarker.updateSettings(tempSettings);
        yield this.plugin.saveSettings();
      }))
    );
    new import_obsidian2.Setting(this.containerEl).setName("Set for a marked task the default text to append automatically").setDesc(
      'Note that this requires "Append text to a task automatically" be enabled. Default "None".'
    ).addDropdown(
      (dropdown) => dropdown.addOption("none", "None").addOption("text-rows-1-2", "Append text according to individual rows").addOption("text-row-string", "Append text according to the row with string").addOption("text-row-1", "Append text always according to row 1").addOption("text-row-2", "Append text always according to row 2").setValue(tempSettings.appendTextAutoTaskDefault).onChange((value) => __async(this, null, function* () {
        tempSettings.appendTextAutoTaskDefault = value;
        this.taskMarker.updateSettings(tempSettings);
        yield this.plugin.saveSettings();
      }))
    );
    new import_obsidian2.Setting(this.containerEl).setName("Set for a non-task line the default text to append automatically").setDesc(
      'Note that this requires "Append text to a task automatically" be enabled. Default "None".'
    ).addDropdown(
      (dropdown) => dropdown.addOption("none", "None").addOption("text-1", "Append text to any line (text 1)").addOption("text-2", "Append text to any line (text 2)").addOption("text-3", "Append text to any line (text 3)").setValue(tempSettings.appendTextAutoLineDefault).onChange((value) => __async(this, null, function* () {
        tempSettings.appendTextAutoLineDefault = value;
        this.taskMarker.updateSettings(tempSettings);
        yield this.plugin.saveSettings();
      }))
    );
    this.containerEl.createEl("h2", {
      text: "Mark tasks using menu items"
    });
    this.containerEl.createEl("p", {
      text: "The following settings add right click context menu items for Task Marker commands. The menu items will work on the current line or within the current selection in Editing view."
    });
    new import_obsidian2.Setting(this.containerEl).setName("Add menu item for creating a task").setDesc(
      'This menu item will work in a way as specified in the section "Create tasks".'
    ).addToggle(
      (toggle) => toggle.setValue(tempSettings.rightClickCreate).onChange((value) => __async(this, null, function* () {
        tempSettings.rightClickCreate = value;
        this.taskMarker.updateSettings(tempSettings);
        yield this.plugin.saveSettings();
      }))
    );
    new import_obsidian2.Setting(this.containerEl).setName("Add menu item for completing a task").setDesc(
      'This menu item will work in a way as specified in the section "Complete tasks".'
    ).addToggle(
      (toggle) => toggle.setValue(tempSettings.rightClickComplete).onChange((value) => __async(this, null, function* () {
        tempSettings.rightClickComplete = value;
        this.taskMarker.updateSettings(tempSettings);
        yield this.plugin.saveSettings();
      }))
    );
    new import_obsidian2.Setting(this.containerEl).setName("Add menu item for marking a task").setDesc(
      'This menu item will work in a way as specified in the section "Mark tasks".'
    ).addToggle(
      (toggle) => toggle.setValue(tempSettings.rightClickMark).onChange((value) => __async(this, null, function* () {
        tempSettings.rightClickMark = value;
        this.taskMarker.updateSettings(tempSettings);
        yield this.plugin.saveSettings();
      }))
    );
    new import_obsidian2.Setting(this.containerEl).setName("Add menu item for cycling a task (main)").setDesc(
      'This menu item will work in a way as specified in the section "Cycle tasks".'
    ).addToggle(
      (toggle) => toggle.setValue(tempSettings.rightClickCycle).onChange((value) => __async(this, null, function* () {
        tempSettings.rightClickCycle = value;
        this.taskMarker.updateSettings(tempSettings);
        yield this.plugin.saveSettings();
      }))
    );
    new import_obsidian2.Setting(this.containerEl).setName("Add menu item for cycling a task reversely (main)").setDesc(
      'This menu item will work in a way as specified in the section "Cycle tasks".'
    ).addToggle(
      (toggle) => toggle.setValue(tempSettings.rightClickCycleReversely).onChange((value) => __async(this, null, function* () {
        tempSettings.rightClickCycleReversely = value;
        this.taskMarker.updateSettings(tempSettings);
        yield this.plugin.saveSettings();
      }))
    );
    new import_obsidian2.Setting(this.containerEl).setName("Add menu item for cycling a task (list 1)").setDesc(
      'This menu item will work in a way as specified in the section "Cycle tasks".'
    ).addToggle(
      (toggle) => toggle.setValue(tempSettings.rightClickCycleList1).onChange((value) => __async(this, null, function* () {
        tempSettings.rightClickCycleList1 = value;
        this.taskMarker.updateSettings(tempSettings);
        yield this.plugin.saveSettings();
      }))
    );
    new import_obsidian2.Setting(this.containerEl).setName("Add menu item for cycling a task (list 2)").setDesc(
      'This menu item will work in a way as specified in the section "Cycle tasks".'
    ).addToggle(
      (toggle) => toggle.setValue(tempSettings.rightClickCycleList2).onChange((value) => __async(this, null, function* () {
        tempSettings.rightClickCycleList2 = value;
        this.taskMarker.updateSettings(tempSettings);
        yield this.plugin.saveSettings();
      }))
    );
    new import_obsidian2.Setting(this.containerEl).setName("Add menu item for cycling a task (list 3)").setDesc(
      'This menu item will work in a way as specified in the section "Cycle tasks".'
    ).addToggle(
      (toggle) => toggle.setValue(tempSettings.rightClickCycleList3).onChange((value) => __async(this, null, function* () {
        tempSettings.rightClickCycleList3 = value;
        this.taskMarker.updateSettings(tempSettings);
        yield this.plugin.saveSettings();
      }))
    );
    new import_obsidian2.Setting(this.containerEl).setName("Add menu item for resetting a task").setDesc(
      "The menu item will reset the task."
    ).addToggle(
      (toggle) => toggle.setValue(tempSettings.rightClickResetTask).onChange((value) => __async(this, null, function* () {
        tempSettings.rightClickResetTask = value;
        this.taskMarker.updateSettings(tempSettings);
        yield this.plugin.saveSettings();
      }))
    );
    new import_obsidian2.Setting(this.containerEl).setName("Add menu item for appending text to a line (text 1)").setDesc(
      'This menu item will work in a way as specified in the section "Append text".'
    ).addToggle(
      (toggle) => toggle.setValue(tempSettings.rightClickAppend).onChange((value) => __async(this, null, function* () {
        tempSettings.rightClickAppend = value;
        this.taskMarker.updateSettings(tempSettings);
        yield this.plugin.saveSettings();
      }))
    );
    new import_obsidian2.Setting(this.containerEl).setName("Add menu item for appending text to a line (text 2)").setDesc(
      'This menu item will work in a way as specified in the section "Append text".'
    ).addToggle(
      (toggle) => toggle.setValue(tempSettings.rightClickAppendText2).onChange((value) => __async(this, null, function* () {
        tempSettings.rightClickAppendText2 = value;
        this.taskMarker.updateSettings(tempSettings);
        yield this.plugin.saveSettings();
      }))
    );
    new import_obsidian2.Setting(this.containerEl).setName("Add menu item for appending text to a line (text 3)").setDesc(
      'This menu item will work in a way as specified in the section "Append text".'
    ).addToggle(
      (toggle) => toggle.setValue(tempSettings.rightClickAppendText3).onChange((value) => __async(this, null, function* () {
        tempSettings.rightClickAppendText3 = value;
        this.taskMarker.updateSettings(tempSettings);
        yield this.plugin.saveSettings();
      }))
    );
    new import_obsidian2.Setting(this.containerEl).setName("Add menu item for appending text automatically").setDesc(
      'This menu item will work in a way as specified in the section "Append text automatically".'
    ).addToggle(
      (toggle) => toggle.setValue(tempSettings.rightClickAppendTextAuto).onChange((value) => __async(this, null, function* () {
        tempSettings.rightClickAppendTextAuto = value;
        this.taskMarker.updateSettings(tempSettings);
        yield this.plugin.saveSettings();
      }))
    );
  }
};

// src/taskmarker-TaskMarkModal.ts
var import_obsidian3 = require("obsidian");
function promptForMark(app, taskMarker) {
  return new Promise((resolve) => {
    const modal = new TaskMarkModal(app, taskMarker);
    modal.onClose = () => {
      resolve(modal.chosenMark);
    };
    modal.open();
  });
}
var TaskMarkModal = class extends import_obsidian3.Modal {
  constructor(app, taskMarker) {
    super(app);
    this.taskMarker = taskMarker;
    this.containerEl.id = "taskmarker-modal";
  }
  onOpen() {
    const selector = this.contentEl.createDiv(
      "taskmarker-selector markdown-preview-view"
    );
    const completedList = selector.createEl("ul");
    completedList.addClass("contains-task-list");
    this.addTaskValues(
      completedList,
      this.taskMarker.initSettings.completedTasks,
      true
    );
    const list = selector.createEl("ul");
    list.addClass("contains-task-list");
    this.addTaskValues(
      list,
      this.taskMarker.settings.incompleteTaskValues,
      false
    );
    const listRow2 = selector.createEl("ul");
    listRow2.addClass("contains-task-list");
    this.addTaskValues(
      listRow2,
      this.taskMarker.settings.incompleteTaskValuesRow2,
      false
    );
    const footer = selector.createEl("nav");
    const esc = footer.createSpan();
    esc.innerHTML = "<b>esc</b> to dismiss";
    const bksp = footer.createSpan();
    bksp.innerHTML = "<b>bksp</b> to remove <code>[]</code>";
    const self = this;
    const keyListener = function(event) {
      self.chosenMark = event.key;
      event.preventDefault();
      event.stopImmediatePropagation();
      self.close();
    };
    this.scope.register([], null, keyListener);
    this.scope.register(["Shift"], null, keyListener);
  }
  addTaskValues(list, choices, markComplete) {
    const self = this;
    for (const character of choices) {
      const li = list.createEl("li", {
        cls: "task-list-item " + (character == " " ? "" : " is-checked"),
        attr: {
          "data-task": character
        }
      });
      li.addEventListener("click", function(event) {
        self.chosenMark = character;
        self.close();
      });
      const input = li.createEl("input", {
        cls: "task-list-item-checkbox",
        attr: {
          id: "task-list-item-checkbox-" + character,
          type: "checkbox",
          style: "pointer-events: none;"
        }
      });
      if (character != " ") {
        input.setAttribute("checked", "");
      }
      li.createEl("span", {
        text: character == " " ? "\u2423" : character,
        attr: {
          style: "pointer-events: none;"
        }
      });
    }
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/taskmarker-Api.ts
var TaskMarkerApi = class {
  constructor(app, taskMarker) {
    this.app = app;
    this.taskMarker = taskMarker;
  }
  getCompletedTaskValues() {
    return this.taskMarker.initSettings.completedTasks;
  }
  getIncompleteTaskValues() {
    return this.taskMarker.settings.incompleteTaskValues;
  }
  getMark() {
    return promptForMark(this.app, this.taskMarker);
  }
  isComplete(value) {
    return this.getCompletedTaskValues().contains(value);
  }
  isCanceled(value) {
    return value === "-";
  }
};

// src/taskmarker-Plugin.ts
var TaskMarkerPlugin = class extends import_obsidian4.Plugin {
  constructor() {
    super(...arguments);
    this.handlersRegistered = false;
  }
  onload() {
    return __async(this, null, function* () {
      console.log("loading Task Marker (TM)");
      this.taskMarker = new TaskMarker(this.app);
      this.addSettingTab(
        new TaskMarkerSettingsTab(this.app, this, this.taskMarker)
      );
      yield this.loadSettings();
      (0, import_obsidian4.addIcon)(
        "tm-create-task" /* CREATE */,
        '<svg xmlns="http://www.w3.org/2000/svg" width="100px" height="100px" fill="currentColor" class="bi bi-check-square-fill" viewBox="0 0 14 14"><rect x="2" y="2" width="10" height="10" fill="white"/></svg>'
      );
      (0, import_obsidian4.addIcon)(
        "tm-complete-task" /* COMPLETE */,
        '<svg xmlns="http://www.w3.org/2000/svg" width="100px" height="100px" fill="currentColor" class="bi bi-check-square-fill" viewBox="0 0 14 14">  <path d="M2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2zm10.03 4.97a.75.75 0 0 1 .011 1.05l-3.992 4.99a.75.75 0 0 1-1.08.02L4.324 8.384a.75.75 0 1 1 1.06-1.06l2.094 2.093 3.473-4.425a.75.75 0 0 1 1.08-.022z"/></svg>'
      );
      (0, import_obsidian4.addIcon)(
        "tm-cancel-task" /* CANCEL */,
        '<svg xmlns="http://www.w3.org/2000/svg" width="100px" height="100px" fill="currentColor" class="bi bi-dash-square-fill" viewBox="0 0 14 14">  <path d="M2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2zm2.5 7.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1 0-1z"/></svg>'
      );
      (0, import_obsidian4.addIcon)(
        "tm-reset-task" /* RESET */,
        '<svg xmlns="http://www.w3.org/2000/svg" width="100px" height="100px" fill="currentColor" class="bi bi-square-fill" viewBox="0 0 14 14"><path d="M0 2a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V2z"/></svg>'
      );
      (0, import_obsidian4.addIcon)(
        "tm-mark-task" /* MARK */,
        '<svg class="bi bi-square-fill" width="100px" height="100px" fill="currentColor" version="1.1" viewBox="0 0 14 14" xmlns="http://www.w3.org/2000/svg"><path transform="scale(.16)" d="m12.5 0a12.5 12.5 0 00-12.5 12.5v75a12.5 12.5 0 0012.5 12.5h75a12.5 12.5 0 0012.5-12.5v-75a12.5 12.5 0 00-12.5-12.5h-75zm38.146 21.135 8.7324 19.098 20.684 3.6328-15.465 14.207 2.9355 20.793-18.289-10.316-18.869 9.2188 4.1602-20.584-14.598-15.098 20.861-2.4043 9.8477-18.547z" stroke-width="6.25"/></svg>'
      );
      (0, import_obsidian4.addIcon)(
        "tm-cycle-task" /* CYCLE */,
        '<svg xmlns="http://www.w3.org/2000/svg" width="100px" height="100px" fill="currentColor" class="bi bi-check-square-fill" viewBox="0 0 14 14"> <rect width="14" height="14" fill="currentColor"/> <text x="50%" y="50%" text-anchor="middle" font-size="12" font-weight="bold" dy=".3em" fill="white">C</text></svg>'
      );
      (0, import_obsidian4.addIcon)(
        "tm-cycle-reversely-task" /* CYCLE_REVERSELY */,
        '<svg xmlns="http://www.w3.org/2000/svg" width="100px" height="100px" fill="currentColor" class="bi bi-check-square-fill" viewBox="0 0 14 14"> <rect width="14" height="14" fill="currentColor"/> <text x="50%" y="50%" text-anchor="middle" font-size="12" font-weight="bold" dy=".3em" fill="white" transform="rotate(180,7,7)">C</text> </svg>'
      );
      (0, import_obsidian4.addIcon)(
        "tm-complete-all-tasks" /* COMPLETE_ALL */,
        '<svg class="bi bi-square-fill" fill="currentColor" version="1.1" width="100px" height="100px" viewBox="0 0 14 14" xmlns="http://www.w3.org/2000/svg"><path d="m2 0a2 2 0 00-2 2v12a2 2 0 002 2h12a2 2 0 002-2v-12a2 2 0 00-2-2h-12zm1.5098 2.041h1.5a1.5 1.5 0 011.5 1.5v1.5a1.5 1.5 0 01-1.5 1.5h-1.5a1.5 1.5 0 01-1.5-1.5v-1.5a1.5 1.5 0 011.5-1.5zm4.3945 1.2207h5.6895a.40645.5 0 01.40625.5v1a.40645.5 0 01-.40625.5h-5.6895a.40645.5 0 01-.40625-.5v-1a.40645.5 0 01.40625-.5zm-4.4023 6.2656h1.5a1.5 1.5 0 011.5 1.5v1.5a1.5 1.5 0 01-1.5 1.5h-1.5a1.5 1.5 0 01-1.5-1.5v-1.5a1.5 1.5 0 011.5-1.5zm4.4023 1.2656h5.6895a.40645.5 0 01.40625.5v1a.40645.5 0 01-.40625.5h-5.6895a.40645.5 0 01-.40625-.5v-1a.40645.5 0 01.40625-.5z"/><g transform="translate(.49737 -.0026315)" fill="currentColor"><path d="m3.6171 13.149a.5.5 0 01-.708 0l-1-1a.50063.50063 0 01.708-.708l.646.647 1.646-1.647a.50063.50063 0 01.708.708z"/><path d="m3.6171 5.6181a.5.5 0 01-.708 0l-1-1a.50063.50063 0 11.708-.708l.646.647 1.646-1.647a.50063.50063 0 11.708.708z"/></g></svg>'
      );
      (0, import_obsidian4.addIcon)(
        "tm-clear-all-tasks" /* CLEAR */,
        '<svg class="bi bi-square-fill" fill="currentColor" version="1.1" width="100px" height="100px" viewBox="0 0 14 14" xmlns="http://www.w3.org/2000/svg"><path d="m2 0a2 2 0 00-2 2v12a2 2 0 002 2h12a2 2 0 002-2v-12a2 2 0 00-2-2h-12zm1.5098 2.041h1.5a1.5 1.5 0 011.5 1.5v1.5a1.5 1.5 0 01-1.5 1.5h-1.5a1.5 1.5 0 01-1.5-1.5v-1.5a1.5 1.5 0 011.5-1.5zm4.3945 1.2207h5.6895a.40645.5 0 01.40625.5v1a.40645.5 0 01-.40625.5h-5.6895a.40645.5 0 01-.40625-.5v-1a.40645.5 0 01.40625-.5zm-4.4023 6.2656h1.5a1.5 1.5 0 011.5 1.5v1.5a1.5 1.5 0 01-1.5 1.5h-1.5a1.5 1.5 0 01-1.5-1.5v-1.5a1.5 1.5 0 011.5-1.5zm4.4023 1.2656h5.6895a.40645.5 0 01.40625.5v1a.40645.5 0 01-.40625.5h-5.6895a.40645.5 0 01-.40625-.5v-1a.40645.5 0 01.40625-.5z"/></svg>'
      );
      this.addCommand({
        id: "task-marker-create",
        name: "Create task",
        icon: "tm-create-task" /* CREATE */,
        editorCallback: (editor, view) => {
          this.markTaskOnLinesCreate(
            " ",
            editor,
            this.getCurrentLinesFromEditor(editor)
          );
        }
      });
      this.addCommand({
        id: "task-marker-complete",
        name: "Complete task",
        icon: "tm-complete-task" /* COMPLETE */,
        editorCallback: (editor, view) => {
          this.markTaskOnLines(
            "x",
            editor,
            this.getCurrentLinesFromEditor(editor)
          );
        }
      });
      this.addCommand({
        id: "task-marker-cancel",
        name: "Cancel task",
        icon: "tm-cancel-task" /* CANCEL */,
        editorCheckCallback: (checking, editor, view) => {
          const value = this.taskMarker.settings.supportCanceledTasks;
          if (value) {
            if (!checking) {
              this.markTaskOnLines(
                "-",
                editor,
                this.getCurrentLinesFromEditor(editor)
              );
            }
            return true;
          }
          return false;
        }
      });
      this.addCommand({
        id: "task-marker-mark",
        name: "Mark task",
        icon: "tm-mark-task" /* MARK */,
        editorCallback: (editor, view) => __async(this, null, function* () {
          const mark = yield promptForMark(this.app, this.taskMarker);
          if (mark) {
            this.markTaskOnLines(
              mark,
              editor,
              this.getCurrentLinesFromEditor(editor)
            );
          }
        })
      });
      this.addCommand({
        id: "task-marker-reset",
        name: "Reset task",
        icon: "tm-reset-task" /* RESET */,
        editorCallback: (editor, view) => {
          this.markTaskOnLines(
            " ",
            editor,
            this.getCurrentLinesFromEditor(editor)
          );
        }
      });
      this.addCommand({
        id: "task-marker-complete-all",
        name: "Complete all tasks",
        icon: "tm-complete-all-tasks" /* COMPLETE_ALL */,
        callback: () => __async(this, null, function* () {
          this.completeAllTasks();
        })
      });
      this.addCommand({
        id: "task-marker-reset-all",
        name: "Reset all completed tasks",
        icon: "tm-clear-all-tasks" /* CLEAR */,
        callback: () => __async(this, null, function* () {
          this.resetAllTasks();
        })
      });
      const incompleteTaskValuesLength = this.taskMarker.settings.incompleteTaskValues.length;
      if (incompleteTaskValuesLength >= 2) {
        for (let i = 1; i <= incompleteTaskValuesLength - 1; i++) {
          this.addCommand({
            id: "task-marker-mark-task-status-row1-" + i.toString(),
            name: "Mark task (row 1) as status " + i.toString() + ' "' + this.taskMarker.settings.incompleteTaskValues[i] + '"',
            icon: "tm-mark-task" /* MARK */,
            editorCallback: (editor, view) => {
              this.markTaskOnLines(
                this.taskMarker.settings.incompleteTaskValues[i],
                editor,
                this.getCurrentLinesFromEditor(editor)
              );
            }
          });
        }
      }
      const incompleteTaskValuesRow2Length = this.taskMarker.settings.incompleteTaskValuesRow2.length;
      if (incompleteTaskValuesRow2Length >= 1) {
        for (let i = 0; i <= incompleteTaskValuesRow2Length - 1; i++) {
          this.addCommand({
            id: "task-marker-mark-task-status-row2-" + (i + 1).toString(),
            name: "Mark task (row 2) as status " + (i + 1).toString() + ' "' + this.taskMarker.settings.incompleteTaskValuesRow2[i] + '"',
            icon: "tm-mark-task" /* MARK */,
            editorCallback: (editor, view) => {
              this.markTaskOnLines(
                this.taskMarker.settings.incompleteTaskValuesRow2[i],
                editor,
                this.getCurrentLinesFromEditor(editor)
              );
            }
          });
        }
      }
      this.addCommand({
        id: "task-marker-cycle-task",
        name: "Cycle task (main)",
        icon: "tm-cycle-task" /* CYCLE */,
        editorCallback: (editor, view) => {
          this.markTaskOnLinesCycle(
            "y",
            // This value does not matter.
            editor,
            this.getCurrentLinesFromEditor(editor)
          );
        }
      });
      this.addCommand({
        id: "task-marker-cycle-task-1",
        name: "Cycle task (list 1)",
        icon: "tm-cycle-task" /* CYCLE */,
        editorCallback: (editor, view) => {
          this.markTaskOnLinesCycleList1(
            "y",
            // This value does not matter.
            editor,
            this.getCurrentLinesFromEditor(editor)
          );
        }
      });
      this.addCommand({
        id: "task-marker-cycle-task-2",
        name: "Cycle task (list 2)",
        icon: "tm-cycle-task" /* CYCLE */,
        editorCallback: (editor, view) => {
          this.markTaskOnLinesCycleList2(
            "y",
            // This value does not matter.
            editor,
            this.getCurrentLinesFromEditor(editor)
          );
        }
      });
      this.addCommand({
        id: "task-marker-cycle-task-3",
        name: "Cycle task (list 3)",
        icon: "tm-cycle-task" /* CYCLE */,
        editorCallback: (editor, view) => {
          this.markTaskOnLinesCycleList3(
            "y",
            // This value does not matter.
            editor,
            this.getCurrentLinesFromEditor(editor)
          );
        }
      });
      this.addCommand({
        id: "task-marker-cycle-task-reversely",
        name: "Cycle task reversely (main)",
        icon: "tm-cycle-reversely-task" /* CYCLE_REVERSELY */,
        editorCheckCallback: (checking, editor, view) => {
          const value = this.taskMarker.settings.supportCyclingTasksReversely;
          if (value) {
            if (!checking) {
              this.markTaskOnLinesCycleReversely(
                "y",
                // This value does not matter.
                editor,
                this.getCurrentLinesFromEditor(editor)
              );
            }
            return true;
          }
          return false;
        }
      });
      this.addCommand({
        id: "task-marker-append-text",
        name: "Append text 1",
        // icon: Icons.RESET,
        editorCallback: (editor, view) => {
          this.appendTextOnLines(
            "y",
            // The mark value does not matter.
            editor,
            this.getCurrentLinesFromEditor(editor)
          );
        }
      });
      this.addCommand({
        id: "task-marker-append-text-2",
        name: "Append text 2",
        // icon: Icons.RESET,
        editorCallback: (editor, view) => {
          this.appendTextOnLinesText2(
            "y",
            // The mark value does not matter.
            editor,
            this.getCurrentLinesFromEditor(editor)
          );
        }
      });
      this.addCommand({
        id: "task-marker-append-text-3",
        name: "Append text 3",
        // icon: Icons.RESET,
        editorCallback: (editor, view) => {
          this.appendTextOnLinesText3(
            "y",
            // The mark value does not matter.
            editor,
            this.getCurrentLinesFromEditor(editor)
          );
        }
      });
      this.addCommand({
        id: "task-marker-append-text-auto",
        name: "Append text automatically",
        // icon: Icons.RESET,
        editorCheckCallback: (checking, editor, view) => {
          const value = this.taskMarker.settings.supportAppendingTextAutomatically;
          if (value) {
            if (!checking) {
              this.appendTextOnLinesAuto(
                "y",
                // The mark value does not matter.
                editor,
                this.getCurrentLinesFromEditor(editor)
              );
            }
            return true;
          }
          return false;
        }
      });
      this.registerHandlers();
      this.api = new TaskMarkerApi(this.app, this.taskMarker);
    });
  }
  getCurrentLinesFromEditor(editor) {
    const lines = [];
    if (editor.somethingSelected()) {
      const cursorStart = editor.getCursor("from");
      const cursorEnd = editor.getCursor("to");
      for (let i = cursorStart.line; i <= cursorEnd.line; i++) {
        lines.push(i);
      }
    } else {
      const anchor = editor.getCursor("from");
      lines.push(anchor.line);
    }
    return lines;
  }
  buildMenu(menu, editor, lines) {
    if (this.taskMarker.settings.rightClickCreate) {
      menu.addItem(
        (item) => item.setTitle("(TM) Create task").setIcon("tm-create-task" /* CREATE */).onClick(() => {
          this.markTaskOnLinesCreate(" ", editor, lines);
        })
      );
    }
    if (this.taskMarker.settings.rightClickComplete) {
      menu.addItem(
        (item) => item.setTitle("(TM) Complete task").setIcon("tm-complete-task" /* COMPLETE */).onClick(() => {
          this.markTaskOnLines("x", editor, lines);
        })
      );
      if (this.taskMarker.settings.supportCanceledTasks) {
        menu.addItem(
          (item) => item.setTitle("(TM) Cancel task").setIcon("tm-cancel-task" /* CANCEL */).onClick(() => {
            this.markTaskOnLines("-", editor, lines);
          })
        );
      }
    }
    if (this.taskMarker.settings.rightClickMark) {
      menu.addItem(
        (item) => item.setTitle("(TM) Mark task").setIcon("tm-mark-task" /* MARK */).onClick(() => __async(this, null, function* () {
          const mark = yield promptForMark(
            this.app,
            this.taskMarker
          );
          if (mark) {
            this.markTaskOnLines(mark, editor, lines);
          }
        }))
      );
    }
    if (this.taskMarker.settings.rightClickCycle) {
      menu.addItem(
        (item) => item.setTitle("(TM) Cycle task (main)").setIcon("tm-cycle-task" /* CYCLE */).onClick(() => {
          this.markTaskOnLinesCycle("y", editor, lines);
        })
      );
    }
    if (this.taskMarker.settings.rightClickCycleList1) {
      menu.addItem(
        (item) => item.setTitle("(TM) Cycle task (list 1)").setIcon("tm-cycle-task" /* CYCLE */).onClick(() => {
          this.markTaskOnLinesCycleList1("y", editor, lines);
        })
      );
    }
    if (this.taskMarker.settings.rightClickCycleList2) {
      menu.addItem(
        (item) => item.setTitle("(TM) Cycle task (list 2)").setIcon("tm-cycle-task" /* CYCLE */).onClick(() => {
          this.markTaskOnLinesCycleList2("y", editor, lines);
        })
      );
    }
    if (this.taskMarker.settings.rightClickCycleList3) {
      menu.addItem(
        (item) => item.setTitle("(TM) Cycle task (list 3)").setIcon("tm-cycle-task" /* CYCLE */).onClick(() => {
          this.markTaskOnLinesCycleList3("y", editor, lines);
        })
      );
    }
    if (this.taskMarker.settings.rightClickCycleReversely) {
      menu.addItem(
        (item) => item.setTitle("(TM) Cycle task reversely (main)").setIcon("tm-cycle-reversely-task" /* CYCLE_REVERSELY */).onClick(() => {
          this.markTaskOnLinesCycleReversely("y", editor, lines);
        })
      );
    }
    if (this.taskMarker.settings.rightClickResetTask) {
      menu.addItem(
        (item) => item.setTitle("(TM) Reset task").setIcon("tm-reset-task" /* RESET */).onClick(() => {
          this.markTaskOnLines(" ", editor, lines);
        })
      );
    }
    if (this.taskMarker.settings.rightClickAppend) {
      menu.addItem(
        (item) => item.setTitle("(TM) Append text 1").onClick(() => {
          this.appendTextOnLines("y", editor, lines);
        })
      );
    }
    if (this.taskMarker.settings.rightClickAppendText2) {
      menu.addItem(
        (item) => item.setTitle("(TM) Append text 2").onClick(() => {
          this.appendTextOnLinesText2("y", editor, lines);
        })
      );
    }
    if (this.taskMarker.settings.rightClickAppendText3) {
      menu.addItem(
        (item) => item.setTitle("(TM) Append text 3").onClick(() => {
          this.appendTextOnLinesText3("y", editor, lines);
        })
      );
    }
    if (this.taskMarker.settings.rightClickAppendTextAuto) {
      menu.addItem(
        (item) => item.setTitle("(TM) Append text automatically").onClick(() => {
          this.appendTextOnLinesAuto("y", editor, lines);
        })
      );
    }
    if (this.taskMarker.settings.rightClickToggleAll) {
      menu.addItem(
        (item) => item.setTitle("(TM) Complete all tasks").setIcon("tm-complete-all-tasks" /* COMPLETE_ALL */).onClick(() => __async(this, null, function* () {
          this.completeAllTasks();
        }))
      );
    }
    if (this.taskMarker.settings.rightClickResetAll) {
      menu.addItem(
        (item) => item.setTitle("(TM) Reset all tasks").setIcon("tm-clear-all-tasks" /* CLEAR */).onClick(() => __async(this, null, function* () {
          this.resetAllTasks();
        }))
      );
    }
  }
  markTaskOnLines(mark, editor, lines) {
    return __async(this, null, function* () {
      const activeFile = this.app.workspace.getActiveFile();
      const source = yield this.app.vault.read(activeFile);
      const cursorPosition = editor.getCursor();
      if (!cursorPosition) {
        console.error("Failed to get cursor position");
        return;
      }
      const result = this.taskMarker.markTaskInSource(source, mark, lines);
      if (!result || !result.updatedLineText || !result.cursorOffset) {
        console.error("Failed to mark task in source");
        return;
      }
      yield this.app.vault.modify(activeFile, result.updatedLineText);
      if (!cursorPosition || !("line" in cursorPosition && "ch" in cursorPosition) || !Array.isArray(result.cursorOffset) || result.cursorOffset.length !== 1) {
        console.error("Invalid cursor position or offset");
        return;
      }
      let newCursorPosition = { line: cursorPosition.line, ch: cursorPosition.ch + result.cursorOffset[0] };
      editor.setCursor(newCursorPosition);
    });
  }
  markTaskOnLinesCycle(mark, editor, lines) {
    return __async(this, null, function* () {
      const activeFile = this.app.workspace.getActiveFile();
      const source = yield this.app.vault.read(activeFile);
      const cursorPosition = editor.getCursor();
      if (!cursorPosition) {
        console.error("Failed to get cursor position");
        return;
      }
      const result = this.taskMarker.markTaskInSourceCycle(source, mark, lines);
      if (!result || !result.updatedLineText || !result.cursorOffset) {
        console.error("Failed to mark task in source");
        return;
      }
      yield this.app.vault.modify(activeFile, result.updatedLineText);
      if (!cursorPosition || !("line" in cursorPosition && "ch" in cursorPosition) || !Array.isArray(result.cursorOffset) || result.cursorOffset.length !== 1) {
        console.error("Invalid cursor position or offset");
        return;
      }
      let newCursorPosition = { line: cursorPosition.line, ch: cursorPosition.ch + result.cursorOffset[0] };
      editor.setCursor(newCursorPosition);
    });
  }
  markTaskOnLinesCycleList1(mark, editor, lines) {
    return __async(this, null, function* () {
      const activeFile = this.app.workspace.getActiveFile();
      const source = yield this.app.vault.read(activeFile);
      const cursorPosition = editor.getCursor();
      if (!cursorPosition) {
        console.error("Failed to get cursor position");
        return;
      }
      const result = this.taskMarker.markTaskInSourceCycleList1(source, mark, lines);
      if (!result || !result.updatedLineText || !result.cursorOffset) {
        console.error("Failed to mark task in source");
        return;
      }
      yield this.app.vault.modify(activeFile, result.updatedLineText);
      if (!cursorPosition || !("line" in cursorPosition && "ch" in cursorPosition) || !Array.isArray(result.cursorOffset) || result.cursorOffset.length !== 1) {
        console.error("Invalid cursor position or offset");
        return;
      }
      let newCursorPosition = { line: cursorPosition.line, ch: cursorPosition.ch + result.cursorOffset[0] };
      editor.setCursor(newCursorPosition);
    });
  }
  markTaskOnLinesCycleList2(mark, editor, lines) {
    return __async(this, null, function* () {
      const activeFile = this.app.workspace.getActiveFile();
      const source = yield this.app.vault.read(activeFile);
      const cursorPosition = editor.getCursor();
      if (!cursorPosition) {
        console.error("Failed to get cursor position");
        return;
      }
      const result = this.taskMarker.markTaskInSourceCycleList2(source, mark, lines);
      if (!result || !result.updatedLineText || !result.cursorOffset) {
        console.error("Failed to mark task in source");
        return;
      }
      yield this.app.vault.modify(activeFile, result.updatedLineText);
      if (!cursorPosition || !("line" in cursorPosition && "ch" in cursorPosition) || !Array.isArray(result.cursorOffset) || result.cursorOffset.length !== 1) {
        console.error("Invalid cursor position or offset");
        return;
      }
      let newCursorPosition = { line: cursorPosition.line, ch: cursorPosition.ch + result.cursorOffset[0] };
      editor.setCursor(newCursorPosition);
    });
  }
  markTaskOnLinesCycleList3(mark, editor, lines) {
    return __async(this, null, function* () {
      const activeFile = this.app.workspace.getActiveFile();
      const source = yield this.app.vault.read(activeFile);
      const cursorPosition = editor.getCursor();
      if (!cursorPosition) {
        console.error("Failed to get cursor position");
        return;
      }
      const result = this.taskMarker.markTaskInSourceCycleList3(source, mark, lines);
      if (!result || !result.updatedLineText || !result.cursorOffset) {
        console.error("Failed to mark task in source");
        return;
      }
      yield this.app.vault.modify(activeFile, result.updatedLineText);
      if (!cursorPosition || !("line" in cursorPosition && "ch" in cursorPosition) || !Array.isArray(result.cursorOffset) || result.cursorOffset.length !== 1) {
        console.error("Invalid cursor position or offset");
        return;
      }
      let newCursorPosition = { line: cursorPosition.line, ch: cursorPosition.ch + result.cursorOffset[0] };
      editor.setCursor(newCursorPosition);
    });
  }
  markTaskOnLinesCycleReversely(mark, editor, lines) {
    return __async(this, null, function* () {
      const activeFile = this.app.workspace.getActiveFile();
      const source = yield this.app.vault.read(activeFile);
      const cursorPosition = editor.getCursor();
      if (!cursorPosition) {
        console.error("Failed to get cursor position");
        return;
      }
      const result = this.taskMarker.markTaskInSourceCycleReversely(source, mark, lines);
      if (!result || !result.updatedLineText || !result.cursorOffset) {
        console.error("Failed to mark task in source");
        return;
      }
      yield this.app.vault.modify(activeFile, result.updatedLineText);
      if (!cursorPosition || !("line" in cursorPosition && "ch" in cursorPosition) || !Array.isArray(result.cursorOffset) || result.cursorOffset.length !== 1) {
        console.error("Invalid cursor position or offset");
        return;
      }
      let newCursorPosition = { line: cursorPosition.line, ch: cursorPosition.ch + result.cursorOffset[0] };
      editor.setCursor(newCursorPosition);
    });
  }
  markTaskOnLinesCreate(mark, editor, lines) {
    return __async(this, null, function* () {
      const activeFile = this.app.workspace.getActiveFile();
      const source = yield this.app.vault.read(activeFile);
      const cursorPosition = editor.getCursor();
      if (!cursorPosition) {
        console.error("Failed to get cursor position");
        return;
      }
      const result = this.taskMarker.markTaskInSourceCreate(source, mark, lines);
      if (!result || !result.updatedLineText || !result.cursorOffset) {
        console.error("Failed to mark task in source");
        return;
      }
      yield this.app.vault.modify(activeFile, result.updatedLineText);
      if (!cursorPosition || !("line" in cursorPosition && "ch" in cursorPosition) || !Array.isArray(result.cursorOffset) || result.cursorOffset.length !== 1) {
        console.error("Invalid cursor position or offset");
        return;
      }
      let newCursorPosition = { line: cursorPosition.line, ch: cursorPosition.ch + result.cursorOffset[0] };
      editor.setCursor(newCursorPosition);
    });
  }
  appendTextOnLines(mark, editor, lines) {
    return __async(this, null, function* () {
      const activeFile = this.app.workspace.getActiveFile();
      const source = yield this.app.vault.read(activeFile);
      const cursorPosition = editor.getCursor();
      const result = this.taskMarker.appendTextInSource(source, mark, lines);
      yield this.app.vault.modify(activeFile, result);
      editor.setCursor(cursorPosition);
    });
  }
  appendTextOnLinesText2(mark, editor, lines) {
    return __async(this, null, function* () {
      const activeFile = this.app.workspace.getActiveFile();
      const source = yield this.app.vault.read(activeFile);
      const cursorPosition = editor.getCursor();
      const result = this.taskMarker.appendTextInSourceText2(source, mark, lines);
      yield this.app.vault.modify(activeFile, result);
      editor.setCursor(cursorPosition);
    });
  }
  appendTextOnLinesText3(mark, editor, lines) {
    return __async(this, null, function* () {
      const activeFile = this.app.workspace.getActiveFile();
      const source = yield this.app.vault.read(activeFile);
      const cursorPosition = editor.getCursor();
      const result = this.taskMarker.appendTextInSourceText3(source, mark, lines);
      yield this.app.vault.modify(activeFile, result);
      editor.setCursor(cursorPosition);
    });
  }
  appendTextOnLinesAuto(mark, editor, lines) {
    return __async(this, null, function* () {
      const activeFile = this.app.workspace.getActiveFile();
      const source = yield this.app.vault.read(activeFile);
      const cursorPosition = editor.getCursor();
      const result = this.taskMarker.appendTextInSourceAuto(source, mark, lines);
      yield this.app.vault.modify(activeFile, result);
      editor.setCursor(cursorPosition);
    });
  }
  // async moveAllTasks(): Promise<void> {
  //     const activeFile = this.app.workspace.getActiveFile();
  //     const source = await this.app.vault.read(activeFile);
  //     const result = this.taskMarker.moveCompletedTasksInFile(source);
  //     this.app.vault.modify(activeFile, result);
  // }
  completeAllTasks() {
    return __async(this, null, function* () {
      const activeFile = this.app.workspace.getActiveFile();
      const source = yield this.app.vault.read(activeFile);
      const result = this.taskMarker.markAllTasksComplete(source, "x");
      this.app.vault.modify(activeFile, result);
    });
  }
  resetAllTasks() {
    return __async(this, null, function* () {
      const activeFile = this.app.workspace.getActiveFile();
      const source = yield this.app.vault.read(activeFile);
      const result = this.taskMarker.resetAllTasks(source);
      this.app.vault.modify(activeFile, result);
    });
  }
  registerHandlers() {
    if (this.taskMarker.initSettings.registerHandlers && !this.handlersRegistered) {
      this.handlersRegistered = true;
      if (this.taskMarker.initSettings.rightClickTaskMenu) {
        this.registerEvent(
          this.eventRef = this.app.workspace.on(
            "editor-menu",
            (menu, editor) => {
              this.buildMenu(
                menu,
                editor,
                this.getCurrentLinesFromEditor(editor)
              );
            }
          )
        );
      }
      this.registerMarkdownPostProcessor(
        this.postProcessor = (el, ctx) => {
          const checkboxes = el.querySelectorAll(
            ".task-list-item-checkbox"
          );
          if (!checkboxes.length)
            return;
          const section = ctx.getSectionInfo(el);
          if (!section)
            return;
          const { lineStart } = section;
          for (const checkbox of Array.from(checkboxes)) {
            const line = Number(checkbox.dataset.line);
            if (this.taskMarker.initSettings.rightClickTaskMenu) {
              this.registerDomEvent(
                checkbox.parentElement,
                "contextmenu",
                (ev) => {
                  ev.preventDefault();
                  const view = this.app.workspace.getActiveViewOfType(
                    import_obsidian4.MarkdownView
                  );
                  if (view && view.editor) {
                    const menu = new import_obsidian4.Menu();
                    this.buildMenu(menu, [
                      lineStart + line
                    ]);
                    menu.showAtMouseEvent(ev);
                  }
                }
              );
            }
            if (this.taskMarker.settings.previewOnClick) {
              this.registerDomEvent(
                checkbox,
                "click",
                (ev) => __async(this, null, function* () {
                  ev.stopImmediatePropagation();
                  ev.preventDefault();
                  const mark = yield promptForMark(
                    this.app,
                    this.taskMarker
                  );
                  if (mark) {
                    this.markTaskOnLines(mark, [
                      lineStart + line
                    ]);
                  }
                })
              );
            }
          }
        }
      );
    }
  }
  unregisterHandlers() {
    this.handlersRegistered = false;
    if (this.eventRef) {
      this.app.workspace.offref(this.eventRef);
      this.eventRef = null;
    }
    if (this.postProcessor) {
      import_obsidian4.MarkdownPreviewRenderer.unregisterPostProcessor(this.postProcessor);
      this.postProcessor = null;
    }
  }
  onunload() {
    console.log("unloading Task Marker (TM)");
  }
  loadSettings() {
    return __async(this, null, function* () {
      const settings = Object.assign(
        {},
        DEFAULT_SETTINGS,
        yield this.loadData()
      );
      if (settings.rightClickReset) {
        delete settings.rightClickReset;
        yield this.saveData(settings);
      }
      this.taskMarker.updateSettings(settings);
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.taskMarker.settings);
      if (this.taskMarker.initSettings.rightClickTaskMenu && !this.handlersRegistered) {
        this.registerHandlers();
      }
      if (!this.taskMarker.initSettings.rightClickTaskMenu && this.handlersRegistered) {
        this.unregisterHandlers();
      }
    });
  }
};

// src/main.ts
var main_default = TaskMarkerPlugin;


/* nosourcemap */